<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Verifactura · Consola de extracción</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        --accent: #2563eb;
        --accent-dark: #1e40af;
        --accent-soft: rgba(37, 99, 235, 0.12);
        --border: #e2e8f0;
        --border-strong: #cbd5f5;
        --text: #0f172a;
        --muted: #64748b;
        --surface: #ffffff;
        --surface-subtle: #f8fafc;
        --danger: #dc2626;
        --danger-soft: rgba(220, 38, 38, 0.12);
        background: var(--surface);
        color: var(--text);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--surface);
      }

      h1,
      h2,
      h3,
      p {
        margin: 0;
      }

      button {
        font: inherit;
        cursor: pointer;
      }

      .app-shell {
        min-height: 100vh;
        padding: clamp(2.5rem, 4vw, 4rem) clamp(1.5rem, 6vw, 5rem) 3rem;
        display: flex;
        flex-direction: column;
        gap: 2.5rem;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-width: 960px;
      }

      header h1 {
        font-size: clamp(1.75rem, 3vw, 2.75rem);
        font-weight: 600;
        letter-spacing: -0.02em;
      }

      header p {
        color: var(--muted);
        font-size: 1rem;
        line-height: 1.6;
        max-width: 72ch;
      }

      .workspace {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 2rem;
        align-items: flex-start;
      }

      .panel {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1.5rem;
        padding: clamp(1.75rem, 2vw, 2.25rem);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        box-shadow: 0 28px 60px -40px rgba(15, 23, 42, 0.3);
      }

      .panel h2 {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .segmented-control {
        display: inline-flex;
        align-self: flex-start;
        background: var(--surface-subtle);
        border-radius: 999px;
        padding: 0.25rem;
        border: 1px solid var(--border);
        gap: 0.25rem;
      }

      .segmented-control button {
        border: none;
        padding: 0.5rem 1.1rem;
        border-radius: 999px;
        color: var(--muted);
        background: transparent;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .segmented-control button.active {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 10px 22px -16px rgba(37, 99, 235, 0.8);
      }

      .drop-zone {
        border: 1.5px dashed var(--border);
        border-radius: 1.25rem;
        padding: clamp(2rem, 4vw, 2.75rem);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.25rem;
        text-align: center;
        background: var(--surface-subtle);
        transition: border-color 0.2s ease, background 0.2s ease;
        position: relative;
      }

      .drop-zone.dragging {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .drop-zone__icon {
        width: 64px;
        height: 64px;
        border-radius: 20px;
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(37, 99, 235, 0));
        display: grid;
        place-items: center;
        color: var(--accent);
        font-size: 1.75rem;
      }

      .drop-zone strong {
        font-size: 1.05rem;
      }

      .drop-zone p {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .drop-zone button {
        border: 1px solid var(--border);
        background: #fff;
        border-radius: 999px;
        padding: 0.6rem 1.4rem;
        font-weight: 500;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .drop-zone button:hover {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .file-details {
        display: grid;
        gap: 1.25rem;
        margin-top: 1.5rem;
      }

      .file-meta {
        display: grid;
        gap: 0.75rem;
        font-size: 0.9rem;
      }

      .file-meta div {
        display: flex;
        align-items: baseline;
        gap: 0.35rem;
      }

      .file-meta span {
        color: var(--muted);
      }

      .file-meta strong {
        color: var(--text);
      }

      .preview {
        background: var(--surface-subtle);
        border: 1px solid var(--border);
        border-radius: 1.1rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .preview-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .preview h3 {
        font-size: 1rem;
        font-weight: 600;
      }

      .preview-action {
        border: 1px solid var(--border);
        background: #fff;
        color: var(--accent);
        font-size: 0.85rem;
        font-weight: 500;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .preview-action:hover,
      .preview-action:focus-visible {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        color: var(--accent-dark);
        outline: none;
      }

      .preview-content {
        max-height: 320px;
        overflow: auto;
        border-radius: 0.75rem;
        background: #fff;
        border: 1px solid var(--border);
      }

      .preview-content iframe,
      .preview-content embed {
        width: 100%;
        height: 320px;
        border: none;
        border-radius: inherit;
      }

      .preview-content img {
        max-width: 100%;
        display: block;
        border-radius: inherit;
      }

      .preview-content pre {
        margin: 0;
        padding: 1rem;
        font-family: "IBM Plex Mono", "Fira Code", monospace;
        font-size: 0.85rem;
        white-space: pre-wrap;
        line-height: 1.5;
      }

      .preview-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        background: rgba(15, 23, 42, 0.65);
        z-index: 1000;
      }

      .preview-modal[hidden] {
        display: none;
      }

      .preview-modal__dialog {
        width: min(960px, 95vw);
        max-height: 90vh;
        background: var(--surface);
        border-radius: 1.25rem;
        border: 1px solid var(--border);
        box-shadow: 0 40px 90px -45px rgba(15, 23, 42, 0.55);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .preview-modal__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid var(--border);
      }

      .preview-modal__header h3 {
        font-size: 1rem;
        font-weight: 600;
        margin: 0;
      }

      .preview-modal__close {
        border: none;
        background: transparent;
        color: var(--muted);
        font-size: 1.75rem;
        line-height: 1;
        padding: 0.25rem;
        cursor: pointer;
        border-radius: 0.5rem;
      }

      .preview-modal__close:hover,
      .preview-modal__close:focus-visible {
        color: var(--text);
        background: var(--surface-subtle);
        outline: none;
      }

      .preview-modal__body {
        flex: 1;
        overflow: auto;
        background: #fff;
        padding: 0;
      }

      .preview-modal__body iframe,
      .preview-modal__body embed {
        width: 100%;
        min-height: 70vh;
        border: none;
      }

      .preview-modal__body img {
        display: block;
        margin: 0 auto;
        max-width: 100%;
        height: auto;
      }

      .preview-modal__body pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "IBM Plex Mono", "Fira Code", monospace;
        font-size: 0.95rem;
        line-height: 1.6;
        white-space: pre-wrap;
      }

      body.modal-open {
        overflow: hidden;
      }

      .multi-details {
        display: grid;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .multi-summary {
        font-size: 0.9rem;
        display: inline-flex;
        align-items: baseline;
        gap: 0.35rem;
        color: var(--muted);
      }

      .multi-summary strong {
        color: var(--text);
      }

      .multi-file-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.75rem;
      }

      .multi-file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        background: var(--surface-subtle);
        border: 1px solid var(--border);
      }

      .multi-file-item span {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        font-size: 0.9rem;
      }

      .multi-file-item small {
        color: var(--muted);
      }

      .multi-file-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .multi-file-item button.remove-button {
        border: none;
        background: transparent;
        color: var(--danger);
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
      }

      .multi-file-item button.remove-button:hover,
      .multi-file-item button.remove-button:focus-visible {
        color: #b91c1c;
        outline: none;
      }

      textarea {
        width: 100%;
        border-radius: 1rem;
        border: 1px solid var(--border);
        min-height: 220px;
        padding: 1rem;
        font: inherit;
        line-height: 1.5;
        background: var(--surface-subtle);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        background: #fff;
      }

      .helper-text {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .toggle input[type="checkbox"] {
        appearance: none;
        width: 44px;
        height: 24px;
        border-radius: 999px;
        background: var(--border);
        position: relative;
        transition: background 0.25s ease;
      }

      .toggle input[type="checkbox"]::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2);
        transition: transform 0.25s ease;
      }

      .toggle input[type="checkbox"]:checked {
        background: var(--accent);
      }

      .toggle input[type="checkbox"]:checked::after {
        transform: translateX(20px);
      }

      .submit-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
      }

      .primary {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 1rem;
        padding: 0.85rem 1.8rem;
        font-weight: 600;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
      }

      .primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px -20px rgba(37, 99, 235, 0.8);
      }

      .secondary {
        border: 1px solid var(--border);
        background: #fff;
        color: var(--muted);
        border-radius: 1rem;
        padding: 0.8rem 1.2rem;
        font-weight: 500;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .secondary:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .status {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .status.error {
        color: var(--danger);
      }

      .results-header {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }

      .results-header p {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .download-group {
        display: inline-flex;
        gap: 0.5rem;
      }

      .download-group button {
        border-radius: 0.9rem;
        padding: 0.65rem 1.1rem;
        border: 1px solid var(--border);
        background: #fff;
        color: var(--muted);
        font-weight: 500;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .download-group button:hover:not(:disabled) {
        border-color: var(--accent);
        color: var(--accent);
      }

      .download-group button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .results-navigation {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        justify-content: flex-end;
      }

      .results-navigation button {
        border: none;
        background: var(--surface-subtle);
        color: var(--accent);
        border-radius: 999px;
        padding: 0.4rem 0.9rem;
        font-weight: 500;
      }

      .result-meta {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .result-meta strong {
        color: var(--text);
      }

      .results-grid {
        display: grid;
        gap: 1rem;
        max-height: 60vh;
        overflow: auto;
        padding-right: 0.25rem;
      }

      .results-grid.empty {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 0.95rem;
        text-align: center;
      }

      .result-field {
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: 0.9rem 1rem;
        background: var(--surface-subtle);
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .result-field label {
        font-weight: 600;
        font-size: 0.92rem;
        color: var(--text);
      }

      .result-field .value {
        font-size: 0.9rem;
        color: var(--text);
        word-break: break-word;
      }

      .result-field .value.missing {
        color: var(--danger);
        border-radius: 0.75rem;
        border: 1px dashed var(--danger);
        background: var(--danger-soft);
        padding: 0.65rem 0.75rem;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        color: var(--muted);
        font-size: 0.8rem;
        padding: 0.35rem 0.75rem;
      }

      @media (max-width: 760px) {
        .app-shell {
          padding: 2rem 1.25rem 3rem;
        }

        .results-navigation {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <h1>Consola inteligente de extracción</h1>
        <p>
          Arrastra y suelta tus facturas o comprobantes en PDF, XML, JSON o imagen. La
          consola detecta el tipo de documento automáticamente y te permite alternar
          entre OCR o lectura directa cuando sea necesario. También puedes ingresar
          texto manualmente como alternativa.
        </p>
      </header>

      <div class="workspace">
        <section class="panel" aria-labelledby="inputHeading">
          <div>
            <h2 id="inputHeading">Entrada del documento</h2>
            <p class="helper-text">
              Formatos admitidos: PDF, XML, JSON, PNG, JPG, JPEG, TIF, TIFF.
            </p>
          </div>

          <div class="segmented-control" role="tablist">
            <button
              type="button"
              id="fileModeButton"
              class="active"
              role="tab"
              aria-selected="true"
            >
              Archivo
            </button>
            <button
              type="button"
              id="textModeButton"
              role="tab"
              aria-selected="false"
            >
              Texto manual
            </button>
            <button
              type="button"
              id="multiModeButton"
              role="tab"
              aria-selected="false"
            >
              Multi-archivo
            </button>
          </div>

          <div id="fileMode" role="tabpanel" aria-labelledby="fileModeButton">
            <div class="drop-zone" id="dropZone" tabindex="0">
              <div class="drop-zone__icon">⬆</div>
              <strong>Arrastra tu archivo aquí</strong>
              <p id="dropInstruction">o haz clic para seleccionarlo desde tu equipo</p>
              <button type="button" id="browseButton">Buscar archivo</button>
              <input
                type="file"
                id="fileInput"
                accept=".pdf,.xml,.json,.png,.jpg,.jpeg,.tif,.tiff"
                hidden
              />
            </div>

            <div class="file-details" id="fileDetails" hidden>
              <div class="file-meta" id="fileMeta">
                <div><span>Archivo:</span> <strong id="fileName">—</strong></div>
                <div><span>Tipo detectado:</span> <strong id="fileType">—</strong></div>
              </div>

              <div class="toggle" id="pdfToggleRow" hidden>
                <input type="checkbox" id="pdfOcrToggle" />
                <label for="pdfOcrToggle">Usar OCR y tratar el PDF como imagen</label>
              </div>

              <div class="preview" id="previewContainer" hidden>
                <div class="preview-header">
                  <h3>Vista previa</h3>
                  <button
                    type="button"
                    id="previewFullscreenButton"
                    class="preview-action"
                    hidden
                  >
                    Ver en pantalla completa
                  </button>
                </div>
                <div class="preview-content" id="previewContent"></div>
              </div>
            </div>
          </div>

          <div id="textMode" role="tabpanel" aria-labelledby="textModeButton" hidden>
            <label for="plainText">Contenido del documento</label>
            <textarea
              id="plainText"
              placeholder="Pega aquí el contenido completo a procesar..."
              aria-label="Contenido del documento en texto"
            ></textarea>
            <p class="helper-text">
              El texto se enviará directamente al modelo de extracción.
            </p>
          </div>

          <div id="multiMode" role="tabpanel" aria-labelledby="multiModeButton" hidden>
            <div class="drop-zone" id="multiDropZone" tabindex="0">
              <div class="drop-zone__icon">📁</div>
              <strong>Agrega varios archivos del mismo tipo</strong>
              <p>Selecciona todos los archivos y los procesaremos en secuencia.</p>
              <button type="button" id="multiBrowseButton">Buscar archivos</button>
              <input
                type="file"
                id="multiFileInput"
                accept=".pdf,.xml,.json,.png,.jpg,.jpeg,.tif,.tiff"
                multiple
                hidden
              />
            </div>

            <div class="multi-details" id="multiDetails" hidden>
              <div class="multi-summary">
                <span>Tipo detectado:</span>
                <strong id="multiTypeLabel">—</strong>
              </div>
              <div class="toggle" id="multiPdfToggleRow" hidden>
                <input type="checkbox" id="multiPdfOcrToggle" />
                <label for="multiPdfOcrToggle">Usar OCR y tratar los PDF como imagen</label>
              </div>
              <ul class="multi-file-list" id="multiFileList"></ul>
            </div>

            <p class="helper-text" id="multiEmptyState">
              Aún no has agregado archivos. Arrástralos o selecciónalos desde tu equipo.
            </p>
          </div>

          <div class="submit-row">
            <button id="submitButton" class="primary">Procesar</button>
            <button id="clearButton" class="secondary" type="button">Limpiar</button>
            <span id="statusMessage" class="status" role="status"></span>
          </div>
        </section>

        <section class="panel" aria-labelledby="outputHeading">
          <div class="results-header">
            <div>
              <h2 id="outputHeading">Resultados</h2>
              <p id="resultsSummary">Procesa un documento para ver los campos extraídos.</p>
            </div>
            <div class="download-group">
              <button id="downloadJson" disabled>Descargar JSON</button>
              <button id="downloadCsv" disabled>Descargar CSV</button>
            </div>
          </div>

          <div class="results-navigation" id="resultsNavigation" hidden>
            <button type="button" id="prevResult">Anterior</button>
            <span id="resultPosition" class="pill"></span>
            <button type="button" id="nextResult">Siguiente</button>
          </div>

          <div class="result-meta" id="resultMeta" hidden></div>

          <div class="results-grid empty" id="resultsContainer">
            Aún no hay resultados. Procesa un documento para comenzar.
          </div>
        </section>
      </div>
    </div>

    <div id="previewModal" class="preview-modal" hidden aria-hidden="true">
      <div
        class="preview-modal__dialog"
        role="dialog"
        aria-modal="true"
        aria-labelledby="previewModalTitle"
      >
        <div class="preview-modal__header">
          <h3 id="previewModalTitle">Vista previa</h3>
          <button
            type="button"
            class="preview-modal__close"
            id="previewModalClose"
            aria-label="Cerrar vista previa"
          >
            &times;
          </button>
        </div>
        <div class="preview-modal__body" id="previewModalContent"></div>
      </div>
    </div>

    <script>
      const SUPPORTED_TYPES = {
        pdf: {
          label: "PDF",
          extensions: ["pdf"],
          endpoint: "file",
        },
        xml: {
          label: "XML",
          extensions: ["xml"],
          endpoint: "file",
        },
        json: {
          label: "JSON",
          extensions: ["json"],
          endpoint: "file",
        },
        image: {
          label: "Imagen",
          extensions: ["png", "jpg", "jpeg", "tif", "tiff"],
          endpoint: "image",
        },
      };

      const ACCEPT_STRING = Object.values(SUPPORTED_TYPES)
        .map((type) => type.extensions.map((ext) => `.${ext}`).join(","))
        .join(",");

      const state = {
        mode: "file",
        file: null,
        fileCategory: null,
        filePreviewUrl: null,
        modalPreviewUrl: null,
        multiFiles: [],
        multiCategory: null,
        multiUseOcr: false,
        results: [],
        currentIndex: -1,
      };

      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const browseButton = document.getElementById("browseButton");
      const fileDetails = document.getElementById("fileDetails");
      const fileMeta = document.getElementById("fileMeta");
      const fileNameElement = document.getElementById("fileName");
      const fileTypeElement = document.getElementById("fileType");
      const pdfToggleRow = document.getElementById("pdfToggleRow");
      const pdfOcrToggle = document.getElementById("pdfOcrToggle");
      const previewContainer = document.getElementById("previewContainer");
      const previewContent = document.getElementById("previewContent");
      const previewFullscreenButton = document.getElementById("previewFullscreenButton");
      const previewModal = document.getElementById("previewModal");
      const previewModalContent = document.getElementById("previewModalContent");
      const previewModalClose = document.getElementById("previewModalClose");
      const submitButton = document.getElementById("submitButton");
      const clearButton = document.getElementById("clearButton");
      const statusMessage = document.getElementById("statusMessage");
      const plainText = document.getElementById("plainText");
      const resultsContainer = document.getElementById("resultsContainer");
      const resultsSummary = document.getElementById("resultsSummary");
      const resultsNavigation = document.getElementById("resultsNavigation");
      const resultPosition = document.getElementById("resultPosition");
      const resultMeta = document.getElementById("resultMeta");
      const downloadJson = document.getElementById("downloadJson");
      const downloadCsv = document.getElementById("downloadCsv");
      const prevResultBtn = document.getElementById("prevResult");
      const nextResultBtn = document.getElementById("nextResult");
      const fileMode = document.getElementById("fileMode");
      const textMode = document.getElementById("textMode");
      const multiMode = document.getElementById("multiMode");
      const fileModeButton = document.getElementById("fileModeButton");
      const textModeButton = document.getElementById("textModeButton");
      const multiModeButton = document.getElementById("multiModeButton");
      const multiDropZone = document.getElementById("multiDropZone");
      const multiBrowseButton = document.getElementById("multiBrowseButton");
      const multiFileInput = document.getElementById("multiFileInput");
      const multiDetails = document.getElementById("multiDetails");
      const multiFileList = document.getElementById("multiFileList");
      const multiTypeLabel = document.getElementById("multiTypeLabel");
      const multiEmptyState = document.getElementById("multiEmptyState");
      const multiPdfToggleRow = document.getElementById("multiPdfToggleRow");
      const multiPdfOcrToggle = document.getElementById("multiPdfOcrToggle");

      let lastFocusedElement = null;

      function setPreviewActionVisibility(visible) {
        previewFullscreenButton.hidden = !visible;
        previewFullscreenButton.disabled = !visible;
      }

      function setPdfToggleVisibility(visible) {
        pdfToggleRow.hidden = !visible;
        pdfToggleRow.setAttribute("aria-hidden", String(!visible));
        pdfToggleRow.style.display = visible ? "flex" : "none";
        if (!visible) {
          pdfOcrToggle.checked = false;
        }
      }

      function setMultiPdfToggleVisibility(visible) {
        multiPdfToggleRow.hidden = !visible;
        multiPdfToggleRow.setAttribute("aria-hidden", String(!visible));
        multiPdfToggleRow.style.display = visible ? "flex" : "none";
        if (!visible) {
          state.multiUseOcr = false;
          multiPdfOcrToggle.checked = false;
        }
      }

      function closePreviewModal() {
        if (previewModal.hidden) {
          return;
        }
        previewModal.hidden = true;
        previewModal.setAttribute("aria-hidden", "true");
        if (state.modalPreviewUrl) {
          URL.revokeObjectURL(state.modalPreviewUrl);
          state.modalPreviewUrl = null;
        }
        previewModalContent.innerHTML = "";
        document.body.classList.remove("modal-open");
        if (lastFocusedElement && typeof lastFocusedElement.focus === "function") {
          lastFocusedElement.focus();
        }
        lastFocusedElement = null;
      }

      function renderModalPreview(file, category, { reusePreviewUrl = false } = {}) {
        previewModalContent.innerHTML = "";
        if (!file || !category) {
          const message = document.createElement("p");
          message.style.padding = "1.25rem";
          message.textContent = "No hay vista previa disponible.";
          previewModalContent.appendChild(message);
          return;
        }

        const revokeModalUrl = () => {
          if (state.modalPreviewUrl) {
            URL.revokeObjectURL(state.modalPreviewUrl);
            state.modalPreviewUrl = null;
          }
        };

        if (category === "image" || category === "pdf") {
          let url = null;
          const shouldReuse = reusePreviewUrl && state.filePreviewUrl;
          if (shouldReuse) {
            url = state.filePreviewUrl;
            revokeModalUrl();
          } else {
            url = URL.createObjectURL(file);
            if (reusePreviewUrl) {
              if (state.filePreviewUrl && state.filePreviewUrl !== url) {
                URL.revokeObjectURL(state.filePreviewUrl);
              }
              state.filePreviewUrl = url;
              revokeModalUrl();
            } else {
              if (state.modalPreviewUrl && state.modalPreviewUrl !== url) {
                URL.revokeObjectURL(state.modalPreviewUrl);
              }
              state.modalPreviewUrl = url;
            }
          }

          if (category === "image") {
            const img = document.createElement("img");
            img.src = url;
            img.alt = "Vista previa ampliada de la imagen subida";
            previewModalContent.appendChild(img);
          } else {
            const iframe = document.createElement("iframe");
            iframe.src = url;
            iframe.title = "Vista previa ampliada del PDF";
            previewModalContent.appendChild(iframe);
          }
        } else {
          revokeModalUrl();
          const placeholder = document.createElement("p");
          placeholder.style.padding = "1.25rem";
          placeholder.textContent = "Cargando vista previa...";
          previewModalContent.appendChild(placeholder);
          const reader = new FileReader();
          reader.onload = () => {
            const text = reader.result || "";
            previewModalContent.innerHTML = "";
            const pre = document.createElement("pre");
            pre.textContent = String(text).slice(0, 20000);
            previewModalContent.appendChild(pre);
          };
          reader.readAsText(file, "utf-8");
        }
      }

      function showModalPreview(file, category, options = {}) {
        if (!file || !category) {
          return;
        }
        renderModalPreview(file, category, options);
        openPreviewModal();
      }

      function openPreviewModal() {
        lastFocusedElement = document.activeElement;
        previewModal.hidden = false;
        previewModal.setAttribute("aria-hidden", "false");
        document.body.classList.add("modal-open");
        previewModalClose.focus();
      }

      previewModalClose.addEventListener("click", () => {
        closePreviewModal();
      });

      previewModal.addEventListener("click", (event) => {
        if (event.target === previewModal) {
          closePreviewModal();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !previewModal.hidden) {
          event.preventDefault();
          closePreviewModal();
        }
      });

      previewFullscreenButton.addEventListener("click", () => {
        if (!state.file || !state.fileCategory) {
          return;
        }
        showModalPreview(state.file, state.fileCategory, { reusePreviewUrl: true });
      });

      setPreviewActionVisibility(false);
      setPdfToggleVisibility(false);
      setMultiPdfToggleVisibility(false);

      fileInput.setAttribute("accept", ACCEPT_STRING);
      multiFileInput.setAttribute("accept", ACCEPT_STRING);

      function resetFile() {
        if (state.filePreviewUrl) {
          URL.revokeObjectURL(state.filePreviewUrl);
        }
        state.file = null;
        state.fileCategory = null;
        state.filePreviewUrl = null;
        fileInput.value = "";
        fileDetails.hidden = true;
        fileNameElement.textContent = "—";
        fileTypeElement.textContent = "—";
        setPdfToggleVisibility(false);
        previewContainer.hidden = true;
        previewContent.innerHTML = "";
        setPreviewActionVisibility(false);
        closePreviewModal();
      }

      function resetMultiFiles() {
        state.multiFiles = [];
        state.multiCategory = null;
        state.multiUseOcr = false;
        multiFileInput.value = "";
        multiDetails.hidden = true;
        multiEmptyState.hidden = false;
        multiFileList.innerHTML = "";
        multiTypeLabel.textContent = "—";
        setMultiPdfToggleVisibility(false);
      }

      function setStatus(message, isError = false) {
        statusMessage.textContent = message;
        statusMessage.classList.toggle("error", Boolean(isError));
      }

      function setActiveModeButton(button, isActive) {
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-selected", String(isActive));
      }

      function switchMode(mode) {
        if (mode === state.mode) return;
        state.mode = mode;
        const isFileMode = mode === "file";
        const isTextMode = mode === "text";
        const isMultiMode = mode === "multi";
        fileMode.hidden = !isFileMode;
        textMode.hidden = !isTextMode;
        multiMode.hidden = !isMultiMode;
        setActiveModeButton(fileModeButton, isFileMode);
        setActiveModeButton(textModeButton, isTextMode);
        setActiveModeButton(multiModeButton, isMultiMode);
        if (isFileMode) {
          resetMultiFiles();
          dropZone.focus();
        } else if (isTextMode) {
          resetFile();
          resetMultiFiles();
          plainText.focus();
        } else {
          resetFile();
          multiDropZone.focus();
        }
        setStatus("");
      }

      fileModeButton.addEventListener("click", () => switchMode("file"));
      textModeButton.addEventListener("click", () => switchMode("text"));
      multiModeButton.addEventListener("click", () => switchMode("multi"));

      function detectCategory(file) {
        const extension = (file.name.split(".").pop() || "").toLowerCase();
        const mime = (file.type || "").toLowerCase();
        if (mime.startsWith("image/")) {
          return "image";
        }
        for (const [key, info] of Object.entries(SUPPORTED_TYPES)) {
          if (info.extensions.includes(extension)) {
            return key;
          }
        }
        if (mime === "application/pdf") {
          return "pdf";
        }
        return null;
      }

      function renderPreview(file, category) {
        closePreviewModal();
        previewContent.innerHTML = "";
        previewContainer.hidden = false;

        if (state.filePreviewUrl) {
          URL.revokeObjectURL(state.filePreviewUrl);
          state.filePreviewUrl = null;
        }

        if (category === "image") {
          const url = URL.createObjectURL(file);
          state.filePreviewUrl = url;
          const img = document.createElement("img");
          img.src = url;
          img.alt = "Vista previa de la imagen subida";
          previewContent.appendChild(img);
        } else if (category === "pdf") {
          const url = URL.createObjectURL(file);
          state.filePreviewUrl = url;
          const iframe = document.createElement("iframe");
          iframe.src = url;
          iframe.title = "Vista previa del PDF";
          previewContent.appendChild(iframe);
        } else {
          const reader = new FileReader();
          reader.onload = () => {
            const text = reader.result || "";
            const snippet = String(text).slice(0, 4000);
            const pre = document.createElement("pre");
            pre.textContent = snippet;
            previewContent.appendChild(pre);
          };
          reader.readAsText(file, "utf-8");
        }
        setPreviewActionVisibility(true);
      }

      function updateFileSelection(file) {
        const category = detectCategory(file);
        if (!category) {
          setStatus("El archivo no es de un formato admitido.", true);
          resetFile();
          return;
        }
        state.file = file;
        state.fileCategory = category;
        fileDetails.hidden = false;
        fileNameElement.textContent = file.name;
        fileTypeElement.textContent = SUPPORTED_TYPES[category].label;
        setPdfToggleVisibility(category === "pdf");
        renderPreview(file, category);
        setStatus("");
      }

      function handleFileList(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        updateFileSelection(fileList[0]);
      }

      function renderMultiList() {
        if (!state.multiFiles.length) {
          resetMultiFiles();
          return;
        }
        multiDetails.hidden = false;
        multiEmptyState.hidden = true;
        const label = SUPPORTED_TYPES[state.multiCategory].label;
        const isPdfBatch = state.multiCategory === "pdf" && state.multiFiles.length > 0;
        setMultiPdfToggleVisibility(isPdfBatch);
        if (isPdfBatch) {
          multiPdfOcrToggle.checked = state.multiUseOcr;
          multiTypeLabel.textContent = `${label}${state.multiUseOcr ? " (OCR)" : ""}`;
        } else {
          multiTypeLabel.textContent = label;
        }
        multiFileList.innerHTML = "";
        state.multiFiles.forEach((entry, index) => {
          const item = document.createElement("li");
          item.className = "multi-file-item";
          const info = document.createElement("span");
          const name = document.createElement("strong");
          name.textContent = entry.file.name;
          const type = document.createElement("small");
          type.textContent =
            entry.category === "pdf" && state.multiUseOcr
              ? `${SUPPORTED_TYPES[entry.category].label} (OCR)`
              : SUPPORTED_TYPES[entry.category].label;
          info.appendChild(name);
          info.appendChild(type);
          const actions = document.createElement("div");
          actions.className = "multi-file-actions";

          const viewButton = document.createElement("button");
          viewButton.type = "button";
          viewButton.textContent = "Ver";
          viewButton.className = "preview-action";
          viewButton.setAttribute(
            "aria-label",
            `Ver ${entry.file.name} en pantalla completa`
          );
          viewButton.addEventListener("click", () => {
            showModalPreview(entry.file, entry.category);
          });

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.textContent = "×";
          removeButton.className = "remove-button";
          removeButton.setAttribute(
            "aria-label",
            `Eliminar ${entry.file.name} de la lista`
          );
          removeButton.addEventListener("click", () => {
            state.multiFiles.splice(index, 1);
            if (!state.multiFiles.length) {
              state.multiCategory = null;
              state.multiUseOcr = false;
              multiPdfOcrToggle.checked = false;
            }
            renderMultiList();
          });

          actions.appendChild(viewButton);
          actions.appendChild(removeButton);

          item.appendChild(info);
          item.appendChild(actions);
          multiFileList.appendChild(item);
        });
      }

      function handleMultiSelection(file) {
        const category = detectCategory(file);
        if (!category) {
          setStatus(`El archivo ${file.name} no es de un formato admitido.`, true);
          return;
        }
        if (state.multiCategory && state.multiCategory !== category) {
          setStatus(
            "Todos los archivos deben ser del mismo tipo para el procesamiento en lote.",
            true
          );
          return;
        }
        state.multiCategory = category;
        if (category !== "pdf") {
          setMultiPdfToggleVisibility(false);
        }
        state.multiFiles.push({ file, category });
        renderMultiList();
        setStatus("");
      }

      function handleMultiFileList(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        Array.from(fileList).forEach((file) => handleMultiSelection(file));
        multiFileInput.value = "";
      }

      browseButton.addEventListener("click", () => {
        if (state.mode !== "file") return;
        fileInput.click();
      });
      fileInput.addEventListener("change", (event) => {
        const files = event.target.files;
        handleFileList(files);
      });

      dropZone.addEventListener("click", () => {
        if (state.mode !== "file") return;
        fileInput.click();
      });

      dropZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.mode === "file") {
          dropZone.classList.add("dragging");
        }
      });

      ["dragleave", "dragend", "drop"].forEach((eventName) => {
        dropZone.addEventListener(eventName, () => dropZone.classList.remove("dragging"));
      });

      dropZone.addEventListener("drop", (event) => {
        event.preventDefault();
        if (state.mode !== "file") {
          return;
        }
        const { files } = event.dataTransfer;
        handleFileList(files);
      });

      multiBrowseButton.addEventListener("click", () => {
        if (state.mode !== "multi") return;
        multiFileInput.click();
      });

      multiFileInput.addEventListener("change", (event) => {
        const files = event.target.files;
        handleMultiFileList(files);
      });

      multiDropZone.addEventListener("click", () => {
        if (state.mode !== "multi") return;
        multiFileInput.click();
      });

      multiDropZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.mode === "multi") {
          multiDropZone.classList.add("dragging");
        }
      });

      ["dragleave", "dragend", "drop"].forEach((eventName) => {
        multiDropZone.addEventListener(eventName, () =>
          multiDropZone.classList.remove("dragging")
        );
      });

      multiDropZone.addEventListener("drop", (event) => {
        event.preventDefault();
        if (state.mode !== "multi") {
          return;
        }
        const { files } = event.dataTransfer;
        handleMultiFileList(files);
      });

      multiPdfOcrToggle.addEventListener("change", () => {
        state.multiUseOcr = multiPdfOcrToggle.checked;
        renderMultiList();
      });

      function flattenData(data, prefix = "") {
        if (data === null || data === undefined) {
          return { [prefix.slice(0, -1)]: null };
        }
        if (typeof data !== "object") {
          return { [prefix.slice(0, -1)]: data };
        }
        if (Array.isArray(data)) {
          if (!data.length) {
            return { [prefix.slice(0, -1)]: [] };
          }
          const result = {};
          data.forEach((value, index) => {
            Object.entries(flattenData(value, `${prefix}${index}.`)).forEach(
              ([key, val]) => {
                result[key] = val;
              }
            );
          });
          return result;
        }
        const entries = Object.entries(data);
        if (!entries.length) {
          return { [prefix.slice(0, -1)]: {} };
        }
        const result = {};
        entries.forEach(([key, value]) => {
          Object.entries(flattenData(value, `${prefix}${key}.`)).forEach(([child, val]) => {
            result[child] = val;
          });
        });
        return result;
      }

      function renderResult(index) {
        if (state.results.length === 0) {
          resultsContainer.classList.add("empty");
          resultsContainer.innerHTML =
            "Aún no hay resultados. Procesa un documento para comenzar.";
          resultsSummary.textContent = "Procesa un documento para ver los campos extraídos.";
          resultsNavigation.hidden = true;
          resultMeta.hidden = true;
          downloadJson.disabled = true;
          downloadCsv.disabled = true;
          return;
        }

        const entry = state.results[index];
        resultsContainer.classList.remove("empty");
        resultsContainer.innerHTML = "";
        resultsSummary.textContent = `Última actualización: ${new Date(
          entry.timestamp
        ).toLocaleString()}`;

        const flat = flattenData(entry.data);
        Object.keys(flat)
          .sort((a, b) => a.localeCompare(b))
          .forEach((key) => {
            const value = flat[key];
            const field = document.createElement("div");
            field.className = "result-field";
            const label = document.createElement("label");
            label.textContent = key || "(valor)";
            const valueElement = document.createElement("div");
            valueElement.className = "value";
            if (value === null || value === undefined || value === "" || (Array.isArray(value) && value.length === 0)) {
              valueElement.classList.add("missing");
              valueElement.textContent = "Sin valor";
            } else if (typeof value === "object") {
              valueElement.textContent = JSON.stringify(value);
            } else {
              valueElement.textContent = String(value);
            }
            field.appendChild(label);
            field.appendChild(valueElement);
            resultsContainer.appendChild(field);
          });

        resultMeta.hidden = false;
        resultMeta.innerHTML = `
          <div><span class="pill">${entry.source}</span></div>
          <div>Procesado el <strong>${new Date(entry.timestamp).toLocaleString()}</strong></div>
        `;

        resultsNavigation.hidden = state.results.length <= 1;
        resultPosition.textContent = `Documento ${index + 1} de ${state.results.length}`;
        resultPosition.setAttribute("aria-live", "polite");
        prevResultBtn.disabled = index === 0;
        nextResultBtn.disabled = index === state.results.length - 1;
        downloadJson.disabled = false;
        downloadCsv.disabled = false;
      }

      function addResultEntry(data, source) {
        const entry = {
          id:
            typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
              ? crypto.randomUUID()
              : Math.random().toString(36).slice(2),
          data,
          source,
          timestamp: Date.now(),
        };
        state.results.push(entry);
        state.currentIndex = state.results.length - 1;
        renderResult(state.currentIndex);
      }

      prevResultBtn.addEventListener("click", () => {
        if (state.currentIndex > 0) {
          state.currentIndex -= 1;
          renderResult(state.currentIndex);
        }
      });

      nextResultBtn.addEventListener("click", () => {
        if (state.currentIndex < state.results.length - 1) {
          state.currentIndex += 1;
          renderResult(state.currentIndex);
        }
      });

      function downloadFile(content, filename, type) {
        const blob = new Blob([content], { type });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      }

      function buildDownloadPayloads() {
        const enriched = state.results.map((entry) => ({
          id: entry.id,
          archivo: entry.source,
          procesado_en: new Date(entry.timestamp).toISOString(),
          datos: entry.data,
        }));
        return enriched;
      }

      downloadJson.addEventListener("click", () => {
        if (!state.results.length) return;
        const payload = buildDownloadPayloads();
        downloadFile(JSON.stringify(payload, null, 2), "resultados_verifactura.json", "application/json");
      });

      downloadCsv.addEventListener("click", () => {
        if (!state.results.length) return;
        const payload = buildDownloadPayloads();
        const allKeys = new Set(["id", "archivo", "procesado_en"]);
        payload.forEach((item) => {
          Object.keys(flattenData(item.datos)).forEach((key) => {
            if (!key) {
              allKeys.add("datos");
            } else {
              allKeys.add(`datos.${key}`);
            }
          });
        });
        const headers = Array.from(allKeys);
        const rows = payload.map((item) => {
          const flat = flattenData(item.datos);
          const values = headers.map((header) => {
            if (header === "id") return item.id;
            if (header === "archivo") return item.archivo;
            if (header === "procesado_en") return item.procesado_en;
            const key = header === "datos" ? "" : header.replace(/^datos\./, "");
            const value = Object.prototype.hasOwnProperty.call(flat, key)
              ? flat[key]
              : null;
            if (value === null || value === undefined) {
              return "";
            }
            if (typeof value === "object") {
              return JSON.stringify(value);
            }
            return String(value);
          });
          return values
            .map((value) => {
              const escaped = String(value).replace(/"/g, '""');
              return `"${escaped}"`;
            })
            .join(",");
        });
        const csv = [headers.join(","), ...rows].join("\n");
        downloadFile(csv, "resultados_verifactura.csv", "text/csv;charset=utf-8");
      });

      function validateBeforeSend() {
        if (state.mode === "text") {
          const value = plainText.value.trim();
          if (!value) {
            throw new Error("Ingresa texto para procesar.");
          }
          return { type: "text", payload: value };
        }
        if (state.mode === "multi") {
          if (!state.multiFiles.length || !state.multiCategory) {
            throw new Error("Agrega al menos un archivo para procesar en lote.");
          }
          return {
            type: "multi",
            payload: {
              category: state.multiCategory,
              files: state.multiFiles.map((entry) => entry.file),
              useOcr: state.multiUseOcr,
            },
          };
        }
        if (!state.file) {
          throw new Error("Selecciona un archivo válido antes de procesar.");
        }
        return { type: state.fileCategory, payload: state.file };
      }

      async function sendText(text) {
        const response = await fetch("/api/v1/extract/text", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text }),
        });
        if (!response.ok) {
          const detail = await response.json().catch(() => ({}));
          throw new Error(detail.detail || "No se pudo procesar el texto.");
        }
        return response.json();
      }

      async function sendFile(file, type, options = {}) {
        const { useOcr = false } = options;
        const formData = new FormData();
        formData.append("file", file);
        let endpoint = "/api/v1/extract/file";
        if (type === "image") {
          endpoint = "/api/v1/extract/image";
        } else if (type === "pdf" && useOcr) {
          endpoint = "/api/v1/extract/file?force_ocr=true";
        }
        const response = await fetch(endpoint, {
          method: "POST",
          body: formData,
        });
        if (!response.ok) {
          const detail = await response.json().catch(() => ({}));
          throw new Error(detail.detail || "No se pudo procesar el archivo.");
        }
        return response.json();
      }

      async function handleSubmit() {
        try {
          setStatus("Procesando...", false);
          submitButton.disabled = true;
          const { type, payload } = validateBeforeSend();
          if (type === "text") {
            const result = await sendText(payload);
            addResultEntry(result, "Texto manual");
          } else if (type === "multi") {
            const { category, files, useOcr } = payload;
            for (let index = 0; index < files.length; index += 1) {
              setStatus(
                `Procesando archivo ${index + 1} de ${files.length}...`,
                false
              );
              const currentFile = files[index];
              const currentResult = await sendFile(currentFile, category, {
                useOcr: category === "pdf" ? useOcr : false,
              });
              const label =
                category === "pdf"
                  ? `${SUPPORTED_TYPES[category].label}${useOcr ? " (OCR)" : ""}`
                  : SUPPORTED_TYPES[category].label;
              const description = `${label} · ${currentFile.name}`;
              addResultEntry(currentResult, description);
            }
            resetMultiFiles();
          } else {
            const useOcr = type === "pdf" ? pdfOcrToggle.checked : false;
            const result = await sendFile(payload, type, { useOcr });
            const description =
              type === "pdf"
                ? `PDF (${useOcr ? "OCR" : "texto"})`
                : SUPPORTED_TYPES[type].label;
            addResultEntry(result, `${description} · ${payload.name}`);
            resetFile();
          }
          setStatus("¡Extracción completada!", false);
        } catch (error) {
          console.error(error);
          setStatus(error.message || "No se pudo completar la solicitud.", true);
        } finally {
          submitButton.disabled = false;
        }
      }

      submitButton.addEventListener("click", () => {
        setStatus("");
        handleSubmit();
      });

      plainText.addEventListener("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          submitButton.click();
        }
      });

      clearButton.addEventListener("click", () => {
        setStatus("");
        plainText.value = "";
        resetFile();
        resetMultiFiles();
      });

      renderResult(state.currentIndex);
    </script>
  </body>
</html>
