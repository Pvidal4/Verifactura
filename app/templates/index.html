<!DOCTYPE html>
<!-- Plantilla principal de la interfaz web de Verifactura -->
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Verifactura · Extracción y validación de facturas vehiculares</title>
    <style>
      /* Variables y estilos base aplicados a toda la página */
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        --accent: #2563eb;
        --accent-dark: #1e40af;
        --accent-soft: rgba(37, 99, 235, 0.12);
        --border: #e2e8f0;
        --border-strong: #cbd5f5;
        --text: #0f172a;
        --muted: #64748b;
        --surface: #ffffff;
        --surface-subtle: #f8fafc;
        --danger: #dc2626;
        --danger-soft: rgba(220, 38, 38, 0.12);
        background: var(--surface);
        color: var(--text);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--surface);
        color: var(--text);
      }

      body:not(.developer-mode) [data-developer-only] {
        display: none !important;
      }

      h1,
      h2,
      h3,
      p {
        margin: 0;
      }

      button {
        font: inherit;
        cursor: pointer;
      }

      /* Contenedor principal que estructura la vista */
      .app-shell {
        min-height: 100vh;
        padding: clamp(2.5rem, 4vw, 4rem) clamp(1.5rem, 6vw, 5rem) 3rem;
        display: flex;
        flex-direction: column;
        gap: 2.5rem;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        max-width: 100%;
      }

      .header-bar {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: clamp(1.5rem, 4vw, 3rem);
        flex-wrap: wrap;
      }

      .header-text {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1 1 64rem;
        min-width: 0;
        max-width: 100%;
      }

      .header-extra {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: flex-start;
        gap: 1rem;
        flex-shrink: 0;
        text-align: right;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .hero-title {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 0.5rem;
        font-size: clamp(1.85rem, 3.2vw, 3rem);
        font-weight: 600;
        letter-spacing: -0.02em;
        color: var(--text);
        max-width: 100%;
      }

      .hero-title__text {
        flex: 0 1 auto;
        min-width: 0;
      }

      .hero-subtitle {
        color: var(--muted);
        font-size: 1rem;
        line-height: 1.6;
        max-width: 100%;
      }

      .hero-logo {
        width: clamp(150px, 18vw, 230px);
        height: auto;
        display: block;
      }

      .developer-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        background: var(--accent-soft);
        color: var(--accent);
        font-size: 0.85rem;
        font-weight: 500;
        flex-shrink: 0;
      }

      .developer-badge[hidden] {
        display: none !important;
      }

      .header-restore[hidden] {
        display: none !important;
      }

      .header-restore {
        align-self: flex-start;
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.5rem 1.1rem;
        font-weight: 500;
        color: var(--accent);
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .header-restore:hover,
      .header-restore:focus-visible {
        border-color: var(--accent);
        color: var(--accent-dark);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      .settings-button {
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.5rem 1.1rem;
        font-weight: 500;
        color: var(--muted);
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .settings-button:hover,
      .settings-button:focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      /* Distribución en cuadrícula de los paneles interactivos */
      .workspace {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 2rem;
        align-items: flex-start;
      }

      /* Estética y espaciado de cada módulo visual */
      .panel {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1.5rem;
        padding: clamp(1.75rem, 2vw, 2.25rem);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        box-shadow: 0 28px 60px -40px rgba(15, 23, 42, 0.3);
      }

      .panel h2 {
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--text);
      }

      .panel--input {
        position: relative;
      }

      .panel-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 1rem;
      }

      .panel-header__text {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .panel-header__actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .preview-mode-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.25rem;
      }

      .preview-mode-toggle[aria-disabled="true"] {
        opacity: 0.6;
      }

      .preview-mode-button {
        border: none;
        background: transparent;
        color: var(--muted);
        font-size: 0.8rem;
        font-weight: 600;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease;
      }

      .preview-mode-button.is-active {
        background: var(--accent-soft);
        color: var(--accent-dark);
      }

      .preview-mode-button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .preview-mode-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .panel-body {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .llm-provider-row,
      .ocr-provider-row {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding: 1rem;
        border-radius: 1rem;
        border: 1px dashed var(--border);
        background: var(--surface-subtle);
      }

      .llm-provider-row label,
      .ocr-provider-row label {
        font-weight: 600;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        color: var(--text);
      }

      .field-label__title {
        font-size: 0.95rem;
        color: inherit;
        font-weight: inherit;
      }

      .llm-provider-row label .field-label__description,
      .ocr-provider-row label .field-label__description {
        font-weight: 400;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .llm-provider-row select,
      .ocr-provider-row select {
        appearance: none;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 0.6rem 0.75rem;
        font-size: 0.95rem;
        background: var(--surface);
        color: var(--text);
      }

      .llm-provider-row select:focus-visible,
      .ocr-provider-row select:focus-visible {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .field-label__row {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .field-label__row label {
        flex: 1;
      }

      .info-button {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--accent);
        font-size: 0.85rem;
        font-weight: 700;
        cursor: pointer;
        flex-shrink: 0;
        transition: background-color 0.2s ease, color 0.2s ease,
          border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .info-button:hover,
      .info-button:focus-visible {
        outline: none;
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .info-button__tooltip {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translate(-50%, 0.5rem);
        min-width: min(240px, 80vw);
        max-width: min(320px, 90vw);
        padding: 0.65rem 0.75rem;
        border-radius: 0.75rem;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--text);
        font-size: 0.8rem;
        line-height: 1.4;
        white-space: normal;
        box-shadow: 0 18px 35px -25px rgba(15, 23, 42, 0.6);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease,
          visibility 0.2s ease;
        z-index: 10;
        text-align: left;
      }

      .info-button:hover .info-button__tooltip,
      .info-button:focus-visible .info-button__tooltip {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, 0.75rem);
      }

      .llm-settings {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        border-radius: 1rem;
        border: 1px dashed var(--border);
        background: var(--surface-subtle);
      }

      .llm-settings__section {
        display: grid;
        gap: 1rem;
      }

      .ocr-settings {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        border-radius: 1rem;
        border: 1px dashed var(--border);
        background: var(--surface-subtle);
      }

      .ocr-settings__fields {
        display: grid;
        gap: 1rem;
      }

      .ocr-settings__fields[hidden] {
        display: none !important;
      }

      .llm-settings__section[hidden] {
        display: none !important;
      }

      .llm-settings__grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .llm-settings__row {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .llm-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.85rem;
        border-radius: 1rem;
        border: 1px solid var(--border);
        background: var(--surface);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .llm-field:focus-within {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .llm-field.is-disabled {
        opacity: 0.6;
      }

      .llm-field__heading {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .llm-field__text {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .llm-field__text label {
        font-weight: 600;
        color: var(--text);
        font-size: 0.95rem;
      }

      .llm-field__text span {
        font-weight: 400;
        color: var(--muted);
        font-size: 0.8rem;
      }

      .llm-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-weight: 500;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .llm-toggle input {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      .llm-settings select,
      .llm-settings input[type="number"],
      .llm-settings input[type="text"],
      .llm-settings input[type="password"] {
        appearance: none;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 0.6rem 0.75rem;
        font-size: 0.95rem;
        background: var(--surface);
        color: var(--text);
      }

      .llm-settings select:focus-visible,
      .llm-settings input[type="number"]:focus-visible,
      .llm-settings input[type="text"]:focus-visible,
      .llm-settings input[type="password"]:focus-visible {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .panel-toggle {
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        border-radius: 999px;
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .panel-toggle:hover,
      .panel-toggle:focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      .panel-toggle span[aria-hidden="true"] {
        font-size: 1rem;
      }

      .segmented-control {
        display: inline-flex;
        align-self: flex-start;
        background: var(--surface-subtle);
        border-radius: 999px;
        padding: 0.25rem;
        border: 1px solid var(--border);
        gap: 0.25rem;
      }

      .segmented-control button {
        border: none;
        padding: 0.5rem 1.1rem;
        border-radius: 999px;
        color: var(--muted);
        background: transparent;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .segmented-control button.active {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 10px 22px -16px rgba(37, 99, 235, 0.8);
      }

      .testing-mode {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .testing-description {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .testing-samples {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }

      .testing-sample {
        border: 1px solid var(--border);
        border-radius: 1rem;
        background: var(--surface);
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .testing-sample:hover,
      .testing-sample:focus-within {
        border-color: var(--accent);
        box-shadow: 0 12px 30px -18px rgba(37, 99, 235, 0.6);
      }

      .testing-sample__icon {
        width: 48px;
        height: 48px;
        border-radius: 14px;
        background: var(--surface-subtle);
        display: grid;
        place-items: center;
        font-size: 1.5rem;
      }

      .testing-sample__body {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .testing-sample__body strong {
        font-size: 1rem;
      }

      .testing-sample__body p {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .testing-sample__meta {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .testing-sample__actions {
        margin-top: auto;
        display: flex;
        gap: 0.5rem;
      }

      .testing-sample__add,
      .testing-sample__view {
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        padding: 0.45rem 0.9rem;
        font-size: 0.9rem;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        color: inherit;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .testing-sample__add:hover,
      .testing-sample__add:focus-visible,
      .testing-sample__view:hover,
      .testing-sample__view:focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      .testing-sample__add:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        border-color: var(--border);
        color: var(--muted);
        box-shadow: none;
      }

      .testing-sample__add:disabled:hover,
      .testing-sample__add:disabled:focus-visible {
        border-color: var(--border);
        color: var(--muted);
        box-shadow: none;
      }

      .testing-selection {
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: 1.25rem;
        background: var(--surface-subtle);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .testing-selection h4 {
        margin: 0;
        font-size: 1rem;
      }

      .testing-selection__empty {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .testing-selection__list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.75rem;
      }

      .testing-selection__item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .testing-selection__info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .testing-selection__info strong {
        font-size: 0.95rem;
      }

      .testing-selection__info span {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .testing-selection__remove {
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        font-size: 0.85rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .testing-selection__remove:hover,
      .testing-selection__remove:focus-visible {
        border-color: var(--danger);
        color: var(--danger);
        box-shadow: 0 0 0 3px var(--danger-soft);
        outline: none;
      }

      .drop-zone {
        border: 1.5px dashed var(--border);
        border-radius: 1.25rem;
        padding: clamp(2rem, 4vw, 2.75rem);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.25rem;
        text-align: center;
        background: var(--surface-subtle);
        transition: border-color 0.2s ease, background 0.2s ease;
        position: relative;
      }

      .drop-zone.dragging {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .drop-zone__icon {
        width: 64px;
        height: 64px;
        border-radius: 20px;
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(37, 99, 235, 0));
        display: grid;
        place-items: center;
        color: var(--accent);
        font-size: 1.75rem;
      }

      .drop-zone strong {
        font-size: 1.05rem;
      }

      .drop-zone p {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .drop-zone button {
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.6rem 1.4rem;
        font-weight: 500;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .drop-zone button:hover {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .file-details {
        display: grid;
        gap: 1.25rem;
        margin-top: 1.5rem;
      }

      .file-meta {
        display: grid;
        gap: 0.75rem;
        font-size: 0.9rem;
      }

      .file-meta div {
        display: flex;
        align-items: baseline;
        gap: 0.35rem;
      }

      .file-meta span {
        color: var(--muted);
      }

      .file-meta strong {
        color: var(--text);
      }

      .preview {
        background: var(--surface-subtle);
        border: 1px solid var(--border);
        border-radius: 1.1rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .preview-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .preview h3 {
        font-size: 1rem;
        font-weight: 600;
      }

      .preview-action {
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--accent);
        font-size: 0.85rem;
        font-weight: 500;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }

      .preview-action:hover,
      .preview-action:focus-visible {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        color: var(--accent-dark);
        outline: none;
      }

      .preview-content {
        max-height: 320px;
        overflow: auto;
        border-radius: 0.75rem;
        background: var(--surface);
        border: 1px solid var(--border);
      }

      .preview-placeholder {
        margin: 0;
        padding: 1.25rem;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .preview-content iframe,
      .preview-content embed {
        width: 100%;
        height: 320px;
        border: none;
        border-radius: inherit;
      }

      .preview-content img {
        max-width: 100%;
        display: block;
        border-radius: inherit;
      }

      .preview-content pre {
        margin: 0;
        padding: 1rem;
        font-family: "IBM Plex Mono", "Fira Code", monospace;
        font-size: 0.85rem;
        white-space: pre-wrap;
        line-height: 1.5;
      }

      .preview-content--missing {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .preview-missing-highlight {
        padding: 0.85rem 1rem;
        border-radius: 0.75rem;
        background: rgba(148, 163, 184, 0.18);
        border: 1px dashed rgba(100, 116, 139, 0.4);
        color: var(--muted);
        font-size: 0.85rem;
        line-height: 1.4;
      }

      .preview-missing-highlight strong {
        font-weight: 600;
        color: var(--text);
      }

      .preview-highlight {
        background: rgba(37, 99, 235, 0.24);
        border-radius: 0.35rem;
        padding: 0.05rem 0.2rem;
        transition: background-color 0.2s ease;
        position: relative;
      }

      .preview-highlight:hover {
        background: rgba(37, 99, 235, 0.35);
      }

      .preview-highlight[data-field]::after {
        display: none;
      }

      .preview-hint {
        margin: 0;
        padding: 1.25rem 1.25rem 0.5rem;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .preview-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        background: rgba(15, 23, 42, 0.65);
        z-index: 1000;
      }

      .preview-modal[hidden] {
        display: none;
      }

      .preview-modal__dialog {
        width: min(960px, 95vw);
        max-height: 90vh;
        background: var(--surface);
        border-radius: 1.25rem;
        border: 1px solid var(--border);
        box-shadow: 0 40px 90px -45px rgba(15, 23, 42, 0.55);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .preview-modal__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid var(--border);
      }

      .preview-modal__header h3 {
        font-size: 1rem;
        font-weight: 600;
        margin: 0;
      }

      .preview-modal__close {
        border: none;
        background: transparent;
        color: var(--muted);
        font-size: 1.75rem;
        line-height: 1;
        padding: 0.25rem;
        cursor: pointer;
        border-radius: 0.5rem;
      }

      .preview-modal__close:hover,
      .preview-modal__close:focus-visible {
        color: var(--text);
        background: var(--surface-subtle);
        outline: none;
      }

      .preview-modal__body {
        flex: 1;
        overflow: auto;
        background: var(--surface);
        padding: 0;
      }

      .preview-modal__body iframe,
      .preview-modal__body embed {
        width: 100%;
        min-height: 70vh;
        border: none;
      }

      .preview-modal__body img {
        display: block;
        margin: 0 auto;
        max-width: 100%;
        height: auto;
      }

      .preview-modal__body pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "IBM Plex Mono", "Fira Code", monospace;
        font-size: 0.95rem;
        line-height: 1.6;
        white-space: pre-wrap;
      }

      body.modal-open {
        overflow: hidden;
      }

      .multi-details {
        display: grid;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .multi-summary {
        font-size: 0.9rem;
        display: inline-flex;
        align-items: baseline;
        gap: 0.35rem;
        color: var(--muted);
      }

      .multi-summary strong {
        color: var(--text);
      }

      .multi-file-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.75rem;
      }

      .multi-file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        background: var(--surface-subtle);
        border: 1px solid var(--border);
      }

      .multi-file-item span {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        font-size: 0.9rem;
      }

      .multi-file-item small {
        color: var(--muted);
      }

      .multi-file-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .multi-file-item button.remove-button {
        border: none;
        background: transparent;
        color: var(--danger);
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
      }

      .multi-file-item button.remove-button:hover,
      .multi-file-item button.remove-button:focus-visible {
        color: #b91c1c;
        outline: none;
      }

      textarea {
        width: 100%;
        border-radius: 1rem;
        border: 1px solid var(--border);
        min-height: 220px;
        padding: 1rem;
        font: inherit;
        line-height: 1.5;
        background: var(--surface-subtle);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
        background: var(--surface);
      }

      .helper-text {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .toggle input[type="checkbox"] {
        appearance: none;
        width: 44px;
        height: 24px;
        border-radius: 999px;
        background: var(--border);
        position: relative;
        transition: background 0.25s ease;
      }

      .toggle input[type="checkbox"]:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .toggle--locked {
        opacity: 0.85;
      }

      .toggle--locked label {
        cursor: not-allowed;
      }

      .toggle input[type="checkbox"]::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2);
        transition: transform 0.25s ease;
      }

      .toggle input[type="checkbox"]:checked {
        background: var(--accent);
      }

      .toggle input[type="checkbox"]:checked::after {
        transform: translateX(20px);
      }

      .submit-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .primary {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 1rem;
        padding: 0.85rem 1.8rem;
        font-weight: 600;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
      }

      .primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px -20px rgba(37, 99, 235, 0.8);
      }

      .secondary {
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        border-radius: 1rem;
        padding: 0.8rem 1.2rem;
        font-weight: 500;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .secondary:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .status {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .status.error {
        color: var(--danger);
      }

      .results-header {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }

      .results-header p {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .download-group {
        display: inline-flex;
        gap: 0.5rem;
      }

      .download-group button {
        border-radius: 0.9rem;
        padding: 0.65rem 1.1rem;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        font-weight: 500;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .download-group button:hover:not(:disabled) {
        border-color: var(--accent);
        color: var(--accent);
      }

      .download-group button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .results-navigation {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        justify-content: flex-end;
      }

      .results-navigation button {
        border: none;
        background: var(--surface-subtle);
        color: var(--accent);
        border-radius: 999px;
        padding: 0.4rem 0.9rem;
        font-weight: 500;
      }

      .result-meta {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .result-meta strong {
        color: var(--text);
      }

      .prediction-card {
        border: 1px solid var(--border);
        background: var(--surface-subtle);
        border-radius: 1.25rem;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .prediction-card__header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .prediction-card__title {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .prediction-card__heading {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .prediction-card__heading h3 {
        margin: 0;
      }

      .prediction-card__title h3 {
        font-size: 1.05rem;
        font-weight: 600;
        color: var(--text);
      }

      .prediction-card__subtitle {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .prediction-card__body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .prediction-placeholder {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .prediction-error {
        margin: 0;
        color: var(--danger);
        font-size: 0.95rem;
      }

      .prediction-retry {
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--accent);
        border-radius: 999px;
        padding: 0.5rem 1.1rem;
        font-weight: 500;
        transition: border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .prediction-retry:hover:not(:disabled),
      .prediction-retry:focus-visible:not(:disabled) {
        border-color: var(--accent);
        color: var(--accent-dark);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      .prediction-retry:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .prediction-result__label {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text);
      }

      .prediction-result {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .prediction-probabilities {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .prediction-probabilities li {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.75rem;
        align-items: center;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        padding: 0.7rem 0.9rem;
      }

      .prediction-probability__name {
        font-weight: 500;
        color: var(--text);
      }

      .prediction-probability__value {
        display: inline-flex;
        gap: 0.4rem;
        align-items: center;
        color: var(--muted);
        font-variant-numeric: tabular-nums;
      }

      .prediction-probability__meter {
        flex: 1;
        height: 0.4rem;
        background: var(--surface-subtle);
        border-radius: 999px;
        overflow: hidden;
        position: relative;
      }

      .prediction-probability__meter-bar {
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, var(--accent) 0%, var(--accent-dark) 100%);
        border-radius: inherit;
      }

      .prediction-note {
        font-size: 0.85rem;
        color: var(--muted);
        margin: 0;
      }

      .results-grid {
        display: grid;
        gap: 1rem;
        max-height: 60vh;
        overflow: auto;
        padding-right: 0.25rem;
      }

      .results-section {
        grid-column: 1 / -1;
        border: 1px solid var(--border);
        border-radius: 1.25rem;
        background: var(--surface);
        padding: 1.1rem 1.25rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .results-section__title {
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text);
        letter-spacing: 0.02em;
      }

      .results-section__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .results-section__toggle {
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        font-size: 0.8rem;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease,
          background-color 0.2s ease;
      }

      .results-section__toggle.is-active {
        border-color: var(--accent);
        background: var(--accent-soft);
        color: var(--accent-dark);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.12);
      }

      .results-section__toggle:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .results-section__grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
      }

      .results-section__grid .result-field {
        background: var(--surface-subtle);
      }

      .results-grid.empty {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 0.95rem;
        text-align: center;
      }

      .workspace--input-hidden {
        grid-template-columns: minmax(0, 1fr);
      }

      .workspace--input-hidden .panel--input {
        display: none;
      }

      .panel--preview {
        display: none;
      }

      .workspace--input-hidden.workspace--with-preview {
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      }

      .workspace--input-hidden.workspace--with-preview .panel--preview {
        display: flex;
      }

      .panel-body--preview {
        gap: 1rem;
        flex: 1;
      }

      .panel-body--preview .preview-content {
        max-height: 60vh;
        flex: 1;
      }

      .settings-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.35);
        backdrop-filter: blur(2px);
        z-index: 300;
      }

      .settings-panel {
        position: fixed;
        top: 0;
        right: 0;
        width: min(320px, 90vw);
        height: 100vh;
        background: var(--surface);
        border-left: 1px solid var(--border);
        box-shadow: -30px 0 60px -40px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        transform: translateX(100%);
        transition: transform 0.25s ease;
        z-index: 400;
      }

      .settings-panel[aria-hidden="false"] {
        transform: translateX(0);
      }

      .settings-panel__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1.25rem 1.5rem;
        border-bottom: 1px solid var(--border);
      }

      .settings-panel__header h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .settings-close {
        border: none;
        background: transparent;
        font-size: 1.5rem;
        color: var(--muted);
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 0.5rem;
      }

      .settings-close:hover,
      .settings-close:focus-visible {
        color: var(--text);
        background: var(--surface-subtle);
        outline: none;
      }

      .settings-panel__body {
        padding: 1.25rem 1.5rem 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        overflow-y: auto;
      }

      .settings-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .settings-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        font-size: 0.95rem;
      }

      .settings-option label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        font-weight: 500;
      }

      .settings-option span {
        color: var(--muted);
        font-size: 0.85rem;
        font-weight: 400;
      }

      .settings-option input[type="checkbox"] {
        width: 46px;
        height: 24px;
      }

      .settings-option select {
        border-radius: 0.75rem;
        border: 1px solid var(--border);
        padding: 0.45rem 0.75rem;
        background: var(--surface-subtle);
        font: inherit;
      }

      .settings-option--action {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      .settings-option__text {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .settings-option__title {
        font-weight: 600;
      }

      .settings-action {
        align-self: flex-start;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.5rem 1.1rem;
        background: var(--surface);
        color: var(--accent);
        font-weight: 500;
        transition: border-color 0.2s ease, box-shadow 0.2s ease,
          color 0.2s ease, background 0.2s ease;
      }

      .settings-action:hover,
      .settings-action:focus-visible {
        border-color: var(--accent);
        color: var(--accent-dark);
        box-shadow: 0 0 0 3px var(--accent-soft);
        outline: none;
      }

      .settings-action[disabled] {
        cursor: progress;
        opacity: 0.6;
        box-shadow: none;
      }

      .settings-option__note {
        color: var(--muted);
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .settings-option__note.is-error {
        color: var(--danger);
      }

      .settings-option__note.is-success {
        color: var(--accent);
      }

      body.theme-dark {
        color-scheme: dark;
        --surface: #0f172a;
        --surface-subtle: #16213c;
        --border: rgba(148, 163, 184, 0.25);
        --border-strong: rgba(148, 163, 184, 0.45);
        --text: #e2e8f0;
        --muted: #cbd5f5;
        background: var(--surface);
        color: var(--text);
      }

      body.theme-dark header h1,
      body.theme-dark header p,
      body.theme-dark .panel h2,
      body.theme-dark .panel-header__text p,
      body.theme-dark .multi-summary,
      body.theme-dark .multi-file-item span,
      body.theme-dark .multi-file-item strong,
      body.theme-dark .settings-button {
        color: var(--text);
      }

      body.theme-dark .settings-button {
        border-color: var(--border-strong);
      }

      .progress-row {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: 0.75rem 1rem;
      }

      .progress-row__meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .progress-track {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: var(--surface-subtle);
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0;
        border-radius: inherit;
        background: linear-gradient(135deg, var(--accent), var(--accent-dark));
        transition: width 0.3s ease;
      }

      .result-field {
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: 0.9rem 1rem;
        background: var(--surface-subtle);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease,
          opacity 0.2s ease;
      }

      .result-field:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft);
      }

      .result-field__header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .result-field__label {
        font-weight: 600;
        font-size: 0.92rem;
        color: var(--text);
        flex: 1;
        min-width: 0;
      }

      .result-field--highlighted {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
        background: rgba(37, 99, 235, 0.05);
      }

      .result-field--focused {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.35);
        background: rgba(37, 99, 235, 0.08);
      }

      .result-field--muted {
        opacity: 0.6;
      }

      .result-field .value {
        font-size: 0.9rem;
        color: var(--text);
        word-break: break-word;
      }

      .result-field .value.missing {
        color: var(--danger);
        border-radius: 0.75rem;
        border: 1px dashed var(--danger);
        background: var(--danger-soft);
        padding: 0.65rem 0.75rem;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        color: var(--muted);
        font-size: 0.8rem;
        padding: 0.35rem 0.75rem;
      }

      @media (min-width: 1400px) {
        .hero-title__text {
          white-space: nowrap;
        }
      }

      @media (max-width: 1024px) {
        .header-bar {
          flex-wrap: wrap;
          align-items: center;
        }

        .header-text {
          flex-basis: 100%;
          min-width: 100%;
        }

        .header-extra {
          flex-direction: row;
          align-items: center;
          justify-content: space-between;
          width: 100%;
          gap: 1.25rem;
          text-align: left;
        }

        .header-actions {
          order: 2;
        }

        .hero-logo {
          width: clamp(140px, 26vw, 210px);
        }
      }

      @media (max-width: 760px) {
        .app-shell {
          padding: 2rem 1.25rem 3rem;
        }

        .header-extra {
          flex-direction: column;
          align-items: stretch;
          justify-content: flex-start;
          gap: 0.75rem;
          text-align: center;
        }

        .header-actions {
          order: initial;
          justify-content: center;
          width: 100%;
        }

        .hero-logo {
          align-self: center;
          width: clamp(110px, 45vw, 160px);
        }

        .results-navigation {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <div class="header-bar">
          <div class="header-text">
            <h1 class="hero-title">
              <span class="hero-title__text"
                >Verifactura · Extracción y validación de facturas vehiculares</span
              >
              <span class="developer-badge" id="developerBadge" hidden
                >Modo desarrollador</span
              >
            </h1>
            <p class="hero-subtitle">
              Carga tus comprobantes y obtén campos normalizados y validados con reglas
              SRI y VIN.
            </p>
            <button
              type="button"
              id="showInputPanelButton"
              class="header-restore"
              hidden
              aria-hidden="true"
            >
              Cargar más facturas
            </button>
          </div>
          <div class="header-extra">
            <div class="header-actions">
              <button
                type="button"
                id="settingsButton"
                class="settings-button"
                aria-haspopup="dialog"
                aria-expanded="false"
              >
                Ajustes
              </button>
            </div>
            <img
              src="{{ request.url_for('static', path='verifactura-logo.svg') }}"
              alt="VeriFactura"
              class="hero-logo"
            />
          </div>
        </div>
      </header>

      <div class="workspace">
        <section class="panel panel--input" aria-labelledby="inputHeading" id="inputPanel">
          <div class="panel-header">
            <div class="panel-header__text">
              <h2 id="inputHeading">Carga de facturas</h2>
              <p class="helper-text">
                Formatos admitidos: PDF, XML, JSON, PNG, JPG, JPEG, TIF, TIFF.
              </p>
            </div>
            <button
              type="button"
              class="panel-toggle"
              id="hideInputPanelButton"
              aria-label="Ocultar sección de carga"
              aria-pressed="false"
            >
              Ocultar
            </button>
          </div>

          <div class="panel-body" id="inputPanelBody">
            <div
              class="llm-provider-row"
              id="llmProviderRow"
              hidden
              aria-hidden="true"
              data-developer-only
            >
              <div class="field-label__row">
                <label for="llmProviderSelect">
                  <span class="field-label__title">Proveedor LLM</span>
                  <span class="field-label__description"
                    >Elige entre el servicio API y el modelo local (GPT OSS
                    20B).</span
                  >
                </label>
                <button
                  type="button"
                  class="info-button"
                  aria-label="Información sobre el proveedor LLM"
                  aria-describedby="llmProviderInfo"
                >
                  <span aria-hidden="true">i</span>
                  <span
                    class="info-button__tooltip"
                    role="tooltip"
                    id="llmProviderInfo"
                  >
                    Selecciona la fuente del modelo de lenguaje usado para
                    interpretar las facturas, ya sea un servicio API hospedado
                    o el modelo local disponible en tu entorno.
                  </span>
                </button>
              </div>
              <select id="llmProviderSelect">
                <option value="api">Servicio API</option>
                <option value="local">Servicio local (GPT OSS 20B)</option>
              </select>
            </div>
            <div
              class="llm-settings"
              id="llmSettings"
              hidden
              aria-hidden="true"
              data-developer-only
            >
              <div
                class="llm-settings__section"
                data-llm-provider-settings="api"
                hidden
                aria-hidden="true"
              >
                <div class="llm-settings__grid">
                  <div class="llm-field" data-developer-only>
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiModel">
                          Modelo (API)
                          <span>
                            Personaliza el identificador del modelo para el servicio
                            API.
                          </span>
                        </label>
                      </div>
                    </div>
                    <input
                      id="llmApiModel"
                      type="text"
                      list="llmApiModelOptions"
                      value="{{ llm_defaults.api.model }}"
                    />
                    <datalist id="llmApiModelOptions">
                      {% for option in llm_defaults.api.options %}
                      <option value="{{ option }}"></option>
                      {% endfor %}
                    </datalist>
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiTemperature">
                          Temperatura
                          <span>Controla la aleatoriedad de las respuestas.</span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmApiTemperatureEnabled">
                        <input
                          type="checkbox"
                          id="llmApiTemperatureEnabled"
                        />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmApiTemperature"
                      type="number"
                      min="0"
                      max="2"
                      step="0.1"
                      value="1"
                    />
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiTopP">
                          Top-p
                          <span>Limita la probabilidad acumulada del muestreo.</span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmApiTopPEnabled">
                        <input type="checkbox" id="llmApiTopPEnabled" />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmApiTopP"
                      type="number"
                      min="0"
                      max="1"
                      step="0.05"
                      value="1"
                    />
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiReasoningEffort">
                          Razonamiento
                          <span>Ajusta el esfuerzo de razonamiento solicitado.</span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmApiReasoningEnabled">
                        <input type="checkbox" id="llmApiReasoningEnabled" />
                        <span>Activado</span>
                      </label>
                    </div>
                    <select id="llmApiReasoningEffort">
                      <option value="minimal">Mínimo</option>
                      <option value="low">Bajo</option>
                      <option value="medium">Medio</option>
                      <option value="high">Alto</option>
                    </select>
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiFrequencyPenalty">
                          Frecuencia
                          <span>
                            Penaliza repeticiones del modelo (-2 a 2).
                          </span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmApiFrequencyEnabled">
                        <input
                          type="checkbox"
                          id="llmApiFrequencyEnabled"
                        />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmApiFrequencyPenalty"
                      type="number"
                      min="-2"
                      max="2"
                      step="0.1"
                      value="0"
                    />
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiPresencePenalty">
                          Presencia
                          <span>Reduce repeticiones temáticas (-2 a 2).</span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmApiPresenceEnabled">
                        <input
                          type="checkbox"
                          id="llmApiPresenceEnabled"
                        />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmApiPresencePenalty"
                      type="number"
                      min="-2"
                      max="2"
                      step="0.1"
                      value="0"
                    />
                  </div>
                </div>
                <div class="llm-settings__row">
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmApiKey">
                          OpenAI API Key
                          <span>
                            Se usará para esta sesión cuando el servicio API esté
                            activo.
                          </span>
                        </label>
                      </div>
                    </div>
                    <input
                      id="llmApiKey"
                      type="password"
                      placeholder="sk-..."
                      autocomplete="off"
                    />
                  </div>
                </div>
              </div>
              <div
                class="llm-settings__section"
                data-llm-provider-settings="local"
                hidden
                aria-hidden="true"
              >
                <div class="llm-settings__grid">
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmLocalModel">
                          Modelo local
                          <span>
                            Indica la ruta o identificador del modelo que deseas
                            cargar.
                          </span>
                        </label>
                      </div>
                    </div>
                    <input
                      id="llmLocalModel"
                      type="text"
                      list="llmLocalModelOptions"
                      value="{{ llm_defaults.local.model }}"
                    />
                    <datalist id="llmLocalModelOptions">
                      {% for option in llm_defaults.local.options %}
                      <option value="{{ option }}"></option>
                      {% endfor %}
                    </datalist>
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmLocalTemperature">
                          Temperatura
                          <span>Ajusta la creatividad del modelo local.</span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmLocalTemperatureEnabled">
                        <input
                          type="checkbox"
                          id="llmLocalTemperatureEnabled"
                        />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmLocalTemperature"
                      type="number"
                      min="0"
                      max="2"
                      step="0.1"
                      value="1"
                    />
                  </div>
                  <div class="llm-field">
                    <div class="llm-field__heading">
                      <div class="llm-field__text">
                        <label for="llmLocalTopP">
                          Top-p
                          <span>
                            Configura el muestreo nucleus del modelo local.
                          </span>
                        </label>
                      </div>
                      <label class="llm-toggle" for="llmLocalTopPEnabled">
                        <input type="checkbox" id="llmLocalTopPEnabled" />
                        <span>Activado</span>
                      </label>
                    </div>
                    <input
                      id="llmLocalTopP"
                      type="number"
                      min="0"
                      max="1"
                      step="0.05"
                      value="1"
                    />
                  </div>
                </div>
              </div>
            </div>
            <div class="ocr-settings" id="ocrSettings" data-developer-only hidden aria-hidden="true">
              <div class="ocr-provider-row">
                <div class="field-label__row">
                  <label for="ocrProviderSelect">
                    <span class="field-label__title">Proveedor OCR</span>
                    <span class="field-label__description">
                      Selecciona el servicio para el reconocimiento óptico de
                      caracteres.
                    </span>
                  </label>
                  <button
                    type="button"
                    class="info-button"
                    aria-label="Información sobre el proveedor OCR"
                    aria-describedby="ocrProviderInfo"
                  >
                    <span aria-hidden="true">i</span>
                    <span
                      class="info-button__tooltip"
                      role="tooltip"
                      id="ocrProviderInfo"
                    >
                      Define qué servicio extrae texto de los documentos cuando
                      requieren reconocimiento óptico, por ejemplo al procesar
                      PDFs escaneados o imágenes.
                    </span>
                  </button>
                </div>
                <select id="ocrProviderSelect">
                  <option value="azure-vision" selected>Azure Vision</option>
                </select>
              </div>
              <div
                class="ocr-settings__fields"
                data-ocr-provider="azure-vision"
                hidden
                aria-hidden="true"
              >
                <div class="llm-field">
                  <div class="llm-field__heading">
                    <div class="llm-field__text">
                      <label for="ocrAzureEndpoint">
                        AZURE_FORM_RECOGNIZER_ENDPOINT
                        <span>
                          Introduce el endpoint de Azure Form Recognizer.
                        </span>
                      </label>
                    </div>
                  </div>
                  <input
                    id="ocrAzureEndpoint"
                    type="text"
                    placeholder="https://<nombre>.cognitiveservices.azure.com/"
                    autocomplete="off"
                  />
                </div>
                <div class="llm-field">
                  <div class="llm-field__heading">
                    <div class="llm-field__text">
                      <label for="ocrAzureKey">
                        AZURE_FORM_RECOGNIZER_KEY
                        <span>Clave del recurso que se usará para el OCR.</span>
                      </label>
                    </div>
                  </div>
                  <input
                    id="ocrAzureKey"
                    type="password"
                    placeholder="Azure key"
                    autocomplete="off"
                  />
                </div>
              </div>
            </div>
            <div class="segmented-control" role="tablist">
              <button
                type="button"
                id="multiModeButton"
                class="active"
                role="tab"
                aria-selected="true"
              >
                Subir archivo
              </button>
              <button
                type="button"
                id="textModeButton"
                role="tab"
                aria-selected="false"
              >
                Ingreso manual
              </button>
              <button
                type="button"
                id="testingModeButton"
                role="tab"
                aria-selected="false"
              >
                Testing
              </button>
            </div>

            <div id="multiMode" role="tabpanel" aria-labelledby="multiModeButton">
              <div class="drop-zone" id="multiDropZone" tabindex="0">
                <div class="drop-zone__icon">📁</div>
                <strong>Selecciona las facturas a procesar</strong>
                <p>Las facturas deben ser del mismo formato.</p>
                <button type="button" id="multiBrowseButton">Buscar archivos</button>
                <input
                  type="file"
                  id="multiFileInput"
                  accept=".pdf,.xml,.json,.png,.jpg,.jpeg,.tif,.tiff"
                  multiple
                  hidden
                />
              </div>

              <div class="multi-details" id="multiDetails" hidden>
                <div class="multi-summary">
                  <span>Tipo detectado:</span>
                  <strong id="multiTypeLabel">—</strong>
                </div>
                <div class="toggle" id="multiPdfToggleRow" hidden>
                  <input type="checkbox" id="multiPdfOcrToggle" />
                  <label for="multiPdfOcrToggle">OCR</label>
                </div>
                <div class="toggle" id="multiVisionToggleRow" hidden>
                  <input type="checkbox" id="multiVisionToggle" />
                  <label for="multiVisionToggle">Visión</label>
                </div>
                <ul class="multi-file-list" id="multiFileList"></ul>
                <div class="progress-row" id="multiProgress" hidden aria-live="polite">
                  <div class="progress-row__meta">
                    <span id="multiProgressText">0 de 0 facturas</span>
                    <strong id="multiProgressPercent">0%</strong>
                  </div>
                  <div
                    class="progress-track"
                    id="multiProgressTrack"
                    role="progressbar"
                    aria-valuemin="0"
                    aria-valuemax="1"
                    aria-valuenow="0"
                  >
                    <div class="progress-bar" id="multiProgressBar"></div>
                  </div>
                </div>
              </div>

              <p class="helper-text" id="multiEmptyState" hidden></p>
            </div>

            <div id="textMode" role="tabpanel" aria-labelledby="textModeButton" hidden>
              <textarea
                id="plainText"
                placeholder="Manualmente coloca el contenido de la factura..."
                aria-label="Contenido manual de la factura"
              ></textarea>
            </div>

            <div id="testingMode" role="tabpanel" aria-labelledby="testingModeButton" hidden>
              <div class="testing-mode">
                <p class="testing-description">
                  Explora estos documentos de ejemplo para validar el flujo de extracción sin buscar archivos locales.
                </p>
                <ul class="testing-samples" id="testingSamplesList">
                  <li
                    class="testing-sample"
                    data-testing-sample
                    data-url="{{ url_for('static', path='testing-samples/factura_pdf_sin_ocr.pdf') }}"
                    data-filename="factura_pdf_sin_ocr.pdf"
                    data-mime="application/pdf"
                    data-requires-ocr="false"
                  >
                    <div class="testing-sample__icon" aria-hidden="true">📄</div>
                    <div class="testing-sample__body">
                      <strong>Factura Digital</strong>
                      <p>Documento PDF con texto seleccionable para validar el procesamiento directo.</p>
                    </div>
                    <div class="testing-sample__actions">
                      <a
                        class="testing-sample__view"
                        href="{{ url_for('static', path='testing-samples/factura_pdf_sin_ocr.pdf') }}"
                        target="_blank"
                        rel="noopener"
                      >
                        Ver
                      </a>
                      <button type="button" class="testing-sample__add">Agregar a la lista</button>
                    </div>
                  </li>
                  <li
                    class="testing-sample"
                    data-testing-sample
                    data-url="{{ url_for('static', path='testing-samples/factura_pdf_con_ocr.pdf') }}"
                    data-filename="factura_pdf_con_ocr.pdf"
                    data-mime="application/pdf"
                    data-requires-ocr="true"
                  >
                    <div class="testing-sample__icon" aria-hidden="true">📄</div>
                    <div class="testing-sample__body">
                      <strong>Factura Escaneada</strong>
                      <p>Archivo escaneado ideal para probar el flujo con reconocimiento óptico.</p>
                    </div>
                    <div class="testing-sample__actions">
                      <a
                        class="testing-sample__view"
                        href="{{ url_for('static', path='testing-samples/factura_pdf_con_ocr.pdf') }}"
                        target="_blank"
                        rel="noopener"
                      >
                        Ver
                      </a>
                      <button type="button" class="testing-sample__add">Agregar a la lista</button>
                    </div>
                  </li>
                  <li
                    class="testing-sample"
                    data-testing-sample
                    data-url="{{ url_for('static', path='testing-samples/factura_imagen.png') }}"
                    data-filename="factura_imagen.png"
                    data-mime="image/png"
                  >
                    <div class="testing-sample__icon" aria-hidden="true">🖼️</div>
                    <div class="testing-sample__body">
                      <strong>Imagen de factura</strong>
                      <p>Imagen ligera para revisar el flujo de extracción basado en fotografías.</p>
                    </div>
                    <div class="testing-sample__actions">
                      <a
                        class="testing-sample__view"
                        href="{{ url_for('static', path='testing-samples/factura_imagen.png') }}"
                        target="_blank"
                        rel="noopener"
                      >
                        Ver
                      </a>
                      <button type="button" class="testing-sample__add">Agregar a la lista</button>
                    </div>
                  </li>
                  <li
                    class="testing-sample"
                    data-testing-sample
                    data-url="{{ url_for('static', path='testing-samples/factura_electronica.xml') }}"
                    data-filename="factura_electronica.xml"
                    data-mime="application/xml"
                  >
                    <div class="testing-sample__icon" aria-hidden="true">🧾</div>
                    <div class="testing-sample__body">
                      <strong>Factura XML</strong>
                      <p>Factura electrónica simplificada para validar la ingesta estructurada.</p>
                    </div>
                    <div class="testing-sample__actions">
                      <a
                        class="testing-sample__view"
                        href="{{ url_for('static', path='testing-samples/factura_electronica.xml') }}"
                        target="_blank"
                        rel="noopener"
                      >
                        Ver
                      </a>
                      <button type="button" class="testing-sample__add">Agregar a la lista</button>
                    </div>
                  </li>
                </ul>
                <div class="testing-selection" id="testingSelection">
                  <h4>Documentos agregados</h4>
                  <div class="toggle" id="testingPdfToggleRow" hidden>
                    <input type="checkbox" id="testingPdfOcrToggle" />
                    <label for="testingPdfOcrToggle">OCR</label>
                  </div>
                  <div class="toggle" id="testingVisionToggleRow" hidden>
                    <input type="checkbox" id="testingVisionToggle" />
                    <label for="testingVisionToggle">Visión</label>
                  </div>
                  <p class="testing-selection__empty" id="testingSelectionEmpty">
                    Aún no agregas documentos de prueba a la lista.
                  </p>
                  <ul class="testing-selection__list" id="testingSelectionList" hidden></ul>
                </div>
              </div>
            </div>

            <div class="submit-row">
              <button id="submitButton" class="primary">Procesar</button>
              <button id="clearButton" class="secondary" type="button">Limpiar</button>
              <span id="statusMessage" class="status" role="status"></span>
            </div>
          </div>
        </section>

        <section class="panel" aria-labelledby="outputHeading">
          <div class="results-header">
            <div>
              <h2 id="outputHeading">Resultados</h2>
              <p id="resultsSummary">Procesa un documento para ver los campos extraídos.</p>
            </div>
            <div class="download-group">
              <button id="viewContentButton" type="button" disabled>
                Ver contenido
              </button>
              <button id="downloadJson" disabled>Descargar JSON</button>
              <button id="downloadCsv" disabled>Descargar CSV</button>
            </div>
          </div>

          <div class="results-navigation" id="resultsNavigation" hidden>
            <button type="button" id="prevResult">Anterior</button>
            <span id="resultPosition" class="pill"></span>
            <button type="button" id="nextResult">Siguiente</button>
          </div>

          <div class="result-meta" id="resultMeta" hidden></div>

          <div class="prediction-card" id="predictionCard" hidden>
            <div class="prediction-card__header">
              <div class="prediction-card__title">
                <div class="prediction-card__heading">
                  <h3>Predicción del modelo</h3>
                  <button
                    type="button"
                    class="info-button"
                    aria-label="Información sobre la predicción del modelo"
                    aria-describedby="predictionInfo"
                  >
                    <span aria-hidden="true">i</span>
                    <span
                      class="info-button__tooltip"
                      role="tooltip"
                      id="predictionInfo"
                    >
                      Visualiza la interpretación del modelo sobre los campos
                      extraídos del documento para validar y comparar los
                      resultados.
                    </span>
                  </button>
                </div>
                <p
                  class="prediction-card__subtitle"
                  id="predictionSubtitle"
                  role="status"
                  aria-live="polite"
                ></p>
              </div>
              <button type="button" class="prediction-retry" id="retryPredictionButton" disabled>
                Reintentar
              </button>
            </div>
            <div class="prediction-card__body" id="predictionContent">
              <p class="prediction-placeholder">
                Proporciona los campos requeridos para ejecutar la predicción.
              </p>
            </div>
          </div>

          <div class="results-grid empty" id="resultsContainer">
            Aún no hay resultados. Procesa un documento para comenzar.
          </div>
        </section>

        <section
          class="panel panel--preview"
          aria-labelledby="previewHeading"
          id="previewPanel"
          hidden
          aria-hidden="true"
        >
          <div class="panel-header">
            <div class="panel-header__text">
              <h2 id="previewHeading">Vista previa</h2>
              <p class="helper-text">Consulta el contenido original del documento seleccionado.</p>
            </div>
            <div class="panel-header__actions">
              <div
                class="preview-mode-toggle"
                id="previewModeToggle"
                role="group"
                aria-label="Modo de vista previa"
              >
                <button
                  type="button"
                  class="preview-mode-button is-active"
                  data-mode="text"
                  aria-pressed="true"
                >
                  Texto
                </button>
                <button
                  type="button"
                  class="preview-mode-button"
                  data-mode="file"
                  aria-pressed="false"
                  disabled
                >
                  Archivo
                </button>
              </div>
            </div>
          </div>
          <div class="panel-body panel-body--preview">
            <p class="preview-hint" id="dockedPreviewHint" hidden></p>
            <div class="preview-content" id="dockedPreviewContent">
              <p class="preview-placeholder">
                Selecciona “Ver contenido” para mostrarlo aquí.
              </p>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div id="previewModal" class="preview-modal" hidden aria-hidden="true">
      <div
        class="preview-modal__dialog"
        role="dialog"
        aria-modal="true"
        aria-labelledby="previewModalTitle"
      >
        <div class="preview-modal__header">
          <h3 id="previewModalTitle">Vista previa</h3>
          <button
            type="button"
            class="preview-modal__close"
            id="previewModalClose"
            aria-label="Cerrar vista previa"
          >
            &times;
          </button>
        </div>
        <div class="preview-modal__body" id="previewModalContent"></div>
      </div>
    </div>

    <div id="settingsBackdrop" class="settings-backdrop" hidden></div>
    <aside
      id="settingsPanel"
      class="settings-panel"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="settingsTitle"
      tabindex="-1"
    >
      <div class="settings-panel__header">
        <h3 id="settingsTitle">Ajustes</h3>
        <button type="button" id="closeSettingsButton" class="settings-close" aria-label="Cerrar ajustes">
          &times;
        </button>
      </div>
      <div class="settings-panel__body">
        <div class="settings-group">
          <div class="settings-option">
            <label for="autoClearToggle">
              Limpiar automáticamente
              <span>Vacía el formulario después de procesar.</span>
            </label>
            <input type="checkbox" id="autoClearToggle" />
          </div>
          <div class="settings-option">
            <label for="themeSelect">
              Apariencia
              <span>Selecciona modo claro u oscuro.</span>
            </label>
            <select id="themeSelect">
              <option value="light">Modo claro</option>
              <option value="dark">Modo oscuro</option>
            </select>
          </div>
          <div class="settings-option">
            <label for="developerToggle">
              Modo desarrollador
              <span>Muestra indicadores adicionales.</span>
            </label>
            <input type="checkbox" id="developerToggle" />
          </div>
          <div
            class="settings-option settings-option--action"
            data-developer-only
            hidden
          >
            <div class="settings-option__text">
              <p class="settings-option__title">Reentrenar Random Forest</p>
              <span>
                Genera un nuevo modelo con el dataset configurado y recarga el
                servicio de predicciones.
              </span>
            </div>
            <button
              type="button"
              class="settings-action"
              id="retrainRandomForestButton"
              data-default-label="Reentrenar Random Forest"
            >
              Reentrenar Random Forest
            </button>
            <p
              class="settings-option__note"
              id="retrainRandomForestStatus"
              aria-live="polite"
              hidden
            ></p>
          </div>
        </div>
      </div>
    </aside>

    <!-- Datos por defecto que el frontend utiliza para precargar modelos -->
    <script id="llmDefaultsData" type="application/json">
      {{ llm_defaults | tojson }}
    </script>
    <!-- Lógica de interacción del panel web -->
    <script>
      // Tipos de archivo permitidos en la interfaz y su endpoint asociado
      const SUPPORTED_TYPES = {
        pdf: {
          label: "PDF",
          extensions: ["pdf"],
          endpoint: "file",
        },
        xml: {
          label: "XML",
          extensions: ["xml"],
          endpoint: "file",
        },
        json: {
          label: "JSON",
          extensions: ["json"],
          endpoint: "file",
        },
        image: {
          label: "Imagen",
          extensions: ["png", "jpg", "jpeg", "tif", "tiff"],
          endpoint: "image",
        },
      };

      const PREDICTION_ENDPOINT = "/api/v1/predictions";
      const RETRAIN_ENDPOINT = "/api/v1/predictions/retrain";
      // Campos que deben estar presentes para enviar una predicción válida
      const PREDICTION_REQUIRED_FIELDS = [
        "marca",
        "tipo",
        "clase",
        "capacidad",
        "combustible",
        "ruedas",
        "total",
      ];
      // Posibles rutas en el JSON que pueden mapearse a cada campo requerido
      const PREDICTION_FIELD_CANDIDATES = {
        marca: [
          "marca",
          "vehiculo.marca",
          "datos_vehiculo.marca",
          "vehiculo.marca_del_vehiculo",
          "datos.marca",
          "vehiculo.datos.marca",
        ],
        tipo: [
          "tipo",
          "vehiculo.tipo",
          "datos_vehiculo.tipo",
          "categoria.tipo",
          "tipo_de_vehiculo",
        ],
        clase: [
          "clase",
          "vehiculo.clase",
          "datos_vehiculo.clase",
          "categoria",
          "clase_vehiculo",
        ],
        capacidad: [
          "capacidad",
          "vehiculo.capacidad",
          "datos_vehiculo.capacidad",
          "capacidad_pasajeros",
          "capacidad.maxima",
          "pasajeros",
        ],
        combustible: [
          "combustible",
          "vehiculo.combustible",
          "datos_vehiculo.combustible",
          "tipo_combustible",
          "combustible.tipo",
        ],
        ruedas: [
          "ruedas",
          "vehiculo.ruedas",
          "datos_vehiculo.ruedas",
          "numero_ruedas",
          "cantidad_ruedas",
        ],
        total: [
          "total",
          "total.total",
          "importe_total",
          "monto_total",
          "factura.total",
          "total_a_pagar",
          "resumen.total",
        ],
      };

      // Valores aceptados para el ajuste de razonamiento del modelo
      const REASONING_EFFORT_VALUES = new Set([
        "minimal",
        "low",
        "medium",
        "high",
        "none",
      ]);

      const llmDefaultsElement = document.getElementById("llmDefaultsData");
      let llmDefaults = {
        api: { model: "gpt-5-mini", options: ["gpt-5-mini"] },
        local: { model: "gpt-oss-20b", options: ["gpt-oss-20b"] },
      };
      if (llmDefaultsElement && llmDefaultsElement.textContent) {
        try {
          const parsed = JSON.parse(llmDefaultsElement.textContent);
          if (parsed && typeof parsed === "object") {
            llmDefaults = {
              api: {
                model: parsed.api?.model || llmDefaults.api.model,
                options: Array.isArray(parsed.api?.options)
                  ? parsed.api.options.filter(Boolean)
                  : llmDefaults.api.options,
              },
              local: {
                model: parsed.local?.model || llmDefaults.local.model,
                options: Array.isArray(parsed.local?.options)
                  ? parsed.local.options.filter(Boolean)
                  : llmDefaults.local.options,
              },
            };
          }
        } catch (error) {
          console.warn("No se pudieron cargar los valores por defecto del LLM.", error);
        }
      }

      // Cadena utilizada para configurar el atributo accept del input de archivos
      const ACCEPT_STRING = Object.values(SUPPORTED_TYPES)
        .map((type) => type.extensions.map((ext) => `.${ext}`).join(","))
        .join(",");

      // Estado global centralizado para sincronizar la interfaz
      const state = {
        mode: "multi",
        modalPreviewUrl: null,
        dockedPreviewUrl: null,
        previewMode: "text",
        multiFiles: [],
        multiCategory: null,
        multiUseOcr: false,
        multiUseVision: false,
        results: [],
        currentIndex: -1,
        currentHighlights: [],
        highlightVisibility: {},
        highlightFocusKey: null,
        missingHighlight: null,
        highlightIndex: Object.create(null),
        llmProvider: "api",
        llmParameters: {
          api: {
            model: llmDefaults.api.model,
            temperature: 1,
            temperature_enabled: false,
            top_p: 1,
            top_p_enabled: false,
            reasoning_effort: "minimal",
            reasoning_effort_enabled: true,
            frequency_penalty: 0,
            frequency_penalty_enabled: false,
            presence_penalty: 0,
            presence_penalty_enabled: false,
            api_key: "",
          },
          local: {
            model: llmDefaults.local.model,
            temperature: 1,
            temperature_enabled: false,
            top_p: 1,
            top_p_enabled: false,
            reasoning_effort: "minimal",
            reasoning_effort_enabled: true,
            frequency_penalty: 0,
            frequency_penalty_enabled: false,
            presence_penalty: 0,
            presence_penalty_enabled: false,
          },
        },
        ocrProvider: "azure-vision",
        ocrParameters: {
          "azure-vision": {
            endpoint: "",
            key: "",
          },
        },
        settings: {
          autoClear: true,
          theme: "light",
          developerMode: false,
        },
      };

      // Referencias a nodos importantes del DOM utilizadas repetidamente
      const previewModal = document.getElementById("previewModal");
      const previewModalContent = document.getElementById("previewModalContent");
      const previewModalClose = document.getElementById("previewModalClose");
      const previewPanel = document.getElementById("previewPanel");
      const dockedPreviewContent = document.getElementById("dockedPreviewContent");
      const dockedPreviewHint = document.getElementById("dockedPreviewHint");
      const previewModeToggle = document.getElementById("previewModeToggle");
      const previewModeButtons = previewModeToggle
        ? Array.from(previewModeToggle.querySelectorAll(".preview-mode-button"))
        : [];
      const previewModeTextButton = previewModeToggle
        ? previewModeToggle.querySelector('[data-mode="text"]')
        : null;
      const previewModeFileButton = previewModeToggle
        ? previewModeToggle.querySelector('[data-mode="file"]')
        : null;
      const submitButton = document.getElementById("submitButton");
      const clearButton = document.getElementById("clearButton");
      const statusMessage = document.getElementById("statusMessage");
      const plainText = document.getElementById("plainText");
      const resultsContainer = document.getElementById("resultsContainer");
      const resultsSummary = document.getElementById("resultsSummary");
      const resultsNavigation = document.getElementById("resultsNavigation");
      const resultPosition = document.getElementById("resultPosition");
      const resultMeta = document.getElementById("resultMeta");
      const predictionCard = document.getElementById("predictionCard");
      const predictionSubtitle = document.getElementById("predictionSubtitle");
      const predictionContent = document.getElementById("predictionContent");
      const retryPredictionButton = document.getElementById("retryPredictionButton");
      const viewContentButton = document.getElementById("viewContentButton");
      const downloadJson = document.getElementById("downloadJson");
      const downloadCsv = document.getElementById("downloadCsv");
      const prevResultBtn = document.getElementById("prevResult");
      const nextResultBtn = document.getElementById("nextResult");
      const textMode = document.getElementById("textMode");
      const multiMode = document.getElementById("multiMode");
      const textModeButton = document.getElementById("textModeButton");
      const multiModeButton = document.getElementById("multiModeButton");
      const testingMode = document.getElementById("testingMode");
      const testingModeButton = document.getElementById("testingModeButton");
      const testingSamplesList = document.getElementById("testingSamplesList");
      const testingSelection = document.getElementById("testingSelection");
      const testingSelectionList = document.getElementById("testingSelectionList");
      const testingSelectionEmpty = document.getElementById("testingSelectionEmpty");
      const testingPdfToggleRow = document.getElementById("testingPdfToggleRow");
      const testingPdfOcrToggle = document.getElementById("testingPdfOcrToggle");
      const testingVisionToggleRow = document.getElementById(
        "testingVisionToggleRow"
      );
      const testingVisionToggle = document.getElementById("testingVisionToggle");

      const multiDropZone = document.getElementById("multiDropZone");
      const multiBrowseButton = document.getElementById("multiBrowseButton");
      const multiFileInput = document.getElementById("multiFileInput");
      const multiDetails = document.getElementById("multiDetails");
      const multiFileList = document.getElementById("multiFileList");
      const multiTypeLabel = document.getElementById("multiTypeLabel");
      const multiEmptyState = document.getElementById("multiEmptyState");
      const multiPdfToggleRow = document.getElementById("multiPdfToggleRow");
      const multiPdfOcrToggle = document.getElementById("multiPdfOcrToggle");
      const multiVisionToggleRow = document.getElementById("multiVisionToggleRow");
      const multiVisionToggle = document.getElementById("multiVisionToggle");
      const workspace = document.querySelector(".workspace");
      const inputPanel = document.getElementById("inputPanel");
      const inputPanelBody = document.getElementById("inputPanelBody");
      const hideInputPanelButton = document.getElementById("hideInputPanelButton");
      const showInputPanelButton = document.getElementById("showInputPanelButton");
      const multiProgress = document.getElementById("multiProgress");
      const multiProgressText = document.getElementById("multiProgressText");
      const multiProgressPercent = document.getElementById("multiProgressPercent");
      const multiProgressTrack = document.getElementById("multiProgressTrack");
      const multiProgressBar = document.getElementById("multiProgressBar");
      const settingsButton = document.getElementById("settingsButton");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsBackdrop = document.getElementById("settingsBackdrop");
      const closeSettingsButton = document.getElementById("closeSettingsButton");
      const autoClearToggle = document.getElementById("autoClearToggle");
      const themeSelect = document.getElementById("themeSelect");
      const developerToggle = document.getElementById("developerToggle");
      const developerBadge = document.getElementById("developerBadge");
      const retrainRandomForestButton = document.getElementById(
        "retrainRandomForestButton"
      );
      const retrainRandomForestStatus = document.getElementById(
        "retrainRandomForestStatus"
      );
      const llmProviderRow = document.getElementById("llmProviderRow");
      const llmProviderSelect = document.getElementById("llmProviderSelect");
      const llmSettingsContainer = document.getElementById("llmSettings");
      const llmSettingsSections = document.querySelectorAll(
        "[data-llm-provider-settings]"
      );
      const ocrSettingsContainer = document.getElementById("ocrSettings");
      const ocrProviderSelect = document.getElementById("ocrProviderSelect");
      const ocrSettingsSections = document.querySelectorAll("[data-ocr-provider]");
      const ocrInputs = {
        "azure-vision": {
          endpoint: document.getElementById("ocrAzureEndpoint"),
          key: document.getElementById("ocrAzureKey"),
        },
      };
      const llmModelInputs = {
        api: document.getElementById("llmApiModel"),
        local: document.getElementById("llmLocalModel"),
      };
      const llmTemperatureInputs = {
        api: document.getElementById("llmApiTemperature"),
        local: document.getElementById("llmLocalTemperature"),
      };
      const llmTopPInputs = {
        api: document.getElementById("llmApiTopP"),
        local: document.getElementById("llmLocalTopP"),
      };
      const llmTemperatureToggles = {
        api: document.getElementById("llmApiTemperatureEnabled"),
        local: document.getElementById("llmLocalTemperatureEnabled"),
      };
      const llmTopPToggles = {
        api: document.getElementById("llmApiTopPEnabled"),
        local: document.getElementById("llmLocalTopPEnabled"),
      };
      const llmReasoningToggles = {
        api: document.getElementById("llmApiReasoningEnabled"),
        local: document.getElementById("llmLocalReasoningEnabled"),
      };
      const llmReasoningInputs = {
        api: document.getElementById("llmApiReasoningEffort"),
        local: document.getElementById("llmLocalReasoningEffort"),
      };
      const llmFrequencyInputs = {
        api: document.getElementById("llmApiFrequencyPenalty"),
        local: document.getElementById("llmLocalFrequencyPenalty"),
      };
      const llmPresenceInputs = {
        api: document.getElementById("llmApiPresencePenalty"),
        local: document.getElementById("llmLocalPresencePenalty"),
      };
      const llmFrequencyToggles = {
        api: document.getElementById("llmApiFrequencyEnabled"),
        local: document.getElementById("llmLocalFrequencyEnabled"),
      };
      const llmPresenceToggles = {
        api: document.getElementById("llmApiPresenceEnabled"),
        local: document.getElementById("llmLocalPresenceEnabled"),
      };
      const llmApiKeyInput = document.getElementById("llmApiKey");
      const developerOnlyElements = document.querySelectorAll("[data-developer-only]");

      let lastFocusedElement = null;
      let lastSettingsTrigger = null;
      let isPreviewDocked = false;
      let dockedFileReadToken = 0;

      // Muestra u oculta el control de OCR para documentos compatibles
      function setOcrToggleVisibility(visible, options = {}) {
        const { locked = false, forceChecked } = options;
        if (!visible) {
          if (multiPdfToggleRow) {
            multiPdfToggleRow.hidden = true;
            multiPdfToggleRow.setAttribute("aria-hidden", "true");
            multiPdfToggleRow.style.display = "none";
            multiPdfToggleRow.classList.remove("toggle--locked");
            multiPdfToggleRow.removeAttribute("aria-disabled");
          }
          if (testingPdfToggleRow) {
            testingPdfToggleRow.hidden = true;
            testingPdfToggleRow.setAttribute("aria-hidden", "true");
            testingPdfToggleRow.style.display = "none";
            testingPdfToggleRow.classList.remove("toggle--locked");
            testingPdfToggleRow.removeAttribute("aria-disabled");
          }
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = false;
            multiPdfOcrToggle.disabled = false;
            multiPdfOcrToggle.removeAttribute("aria-disabled");
          }
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = false;
            testingPdfOcrToggle.disabled = false;
            testingPdfOcrToggle.removeAttribute("aria-disabled");
          }
          state.multiUseOcr = false;
          return;
        }

        if (typeof forceChecked === "boolean") {
          state.multiUseOcr = forceChecked;
        }

        const showInMulti = state.mode === "multi";
        const showInTesting = state.mode === "testing";

        if (multiPdfToggleRow) {
          multiPdfToggleRow.hidden = !showInMulti;
          multiPdfToggleRow.setAttribute("aria-hidden", String(!showInMulti));
          multiPdfToggleRow.style.display = showInMulti ? "flex" : "none";
          multiPdfToggleRow.classList.toggle("toggle--locked", locked);
          multiPdfToggleRow.setAttribute("aria-disabled", String(locked));
        }
        if (testingPdfToggleRow) {
          testingPdfToggleRow.hidden = !showInTesting;
          testingPdfToggleRow.setAttribute("aria-hidden", String(!showInTesting));
          testingPdfToggleRow.style.display = showInTesting ? "flex" : "none";
          testingPdfToggleRow.classList.toggle("toggle--locked", locked);
          testingPdfToggleRow.setAttribute("aria-disabled", String(locked));
        }

        if (multiPdfOcrToggle) {
          multiPdfOcrToggle.checked = state.multiUseOcr;
          multiPdfOcrToggle.disabled = Boolean(locked);
          if (locked) {
            multiPdfOcrToggle.setAttribute("aria-disabled", "true");
          } else {
            multiPdfOcrToggle.removeAttribute("aria-disabled");
          }
        }
        if (testingPdfOcrToggle) {
          testingPdfOcrToggle.checked = state.multiUseOcr;
          testingPdfOcrToggle.disabled = Boolean(locked);
          if (locked) {
            testingPdfOcrToggle.setAttribute("aria-disabled", "true");
          } else {
            testingPdfOcrToggle.removeAttribute("aria-disabled");
          }
        }
      }

      function setVisionToggleVisibility(visible, options = {}) {
        const { locked = false, forceChecked } = options;
        if (!visible) {
          if (multiVisionToggleRow) {
            multiVisionToggleRow.hidden = true;
            multiVisionToggleRow.setAttribute("aria-hidden", "true");
            multiVisionToggleRow.style.display = "none";
            multiVisionToggleRow.classList.remove("toggle--locked");
            multiVisionToggleRow.removeAttribute("aria-disabled");
          }
          if (testingVisionToggleRow) {
            testingVisionToggleRow.hidden = true;
            testingVisionToggleRow.setAttribute("aria-hidden", "true");
            testingVisionToggleRow.style.display = "none";
            testingVisionToggleRow.classList.remove("toggle--locked");
            testingVisionToggleRow.removeAttribute("aria-disabled");
          }
          if (multiVisionToggle) {
            multiVisionToggle.checked = false;
            multiVisionToggle.disabled = false;
            multiVisionToggle.removeAttribute("aria-disabled");
          }
          if (testingVisionToggle) {
            testingVisionToggle.checked = false;
            testingVisionToggle.disabled = false;
            testingVisionToggle.removeAttribute("aria-disabled");
          }
          state.multiUseVision = false;
          return;
        }

        if (typeof forceChecked === "boolean") {
          state.multiUseVision = forceChecked;
        }

        const showInMulti = state.mode === "multi";
        const showInTesting = state.mode === "testing";

        if (multiVisionToggleRow) {
          multiVisionToggleRow.hidden = !showInMulti;
          multiVisionToggleRow.setAttribute("aria-hidden", String(!showInMulti));
          multiVisionToggleRow.style.display = showInMulti ? "flex" : "none";
          multiVisionToggleRow.classList.toggle("toggle--locked", locked);
          multiVisionToggleRow.setAttribute("aria-disabled", String(locked));
        }
        if (testingVisionToggleRow) {
          testingVisionToggleRow.hidden = !showInTesting;
          testingVisionToggleRow.setAttribute(
            "aria-hidden",
            String(!showInTesting)
          );
          testingVisionToggleRow.style.display = showInTesting ? "flex" : "none";
          testingVisionToggleRow.classList.toggle("toggle--locked", locked);
          testingVisionToggleRow.setAttribute("aria-disabled", String(locked));
        }

        if (multiVisionToggle) {
          multiVisionToggle.checked = state.multiUseVision;
          multiVisionToggle.disabled = Boolean(locked);
          if (locked) {
            multiVisionToggle.setAttribute("aria-disabled", "true");
          } else {
            multiVisionToggle.removeAttribute("aria-disabled");
          }
        }
        if (testingVisionToggle) {
          testingVisionToggle.checked = state.multiUseVision;
          testingVisionToggle.disabled = Boolean(locked);
          if (locked) {
            testingVisionToggle.setAttribute("aria-disabled", "true");
          } else {
            testingVisionToggle.removeAttribute("aria-disabled");
          }
        }
      }

      // Activa la clase de tema oscuro o claro según la selección del usuario
      function applyTheme(theme) {
        document.body.classList.toggle("theme-dark", theme === "dark");
      }

      // Devuelve la configuración del LLM respetando el modo desarrollador
      function getActiveLlmSettings() {
        const params = ensureLlmParameters(state.llmProvider);
        if (state.settings.developerMode) {
          return params;
        }
        const sanitized = {
          ...params,
          temperature_enabled: false,
          top_p_enabled: false,
          reasoning_effort_enabled: false,
          frequency_penalty_enabled: false,
          presence_penalty_enabled: false,
        };
        if (state.llmProvider === "api") {
          sanitized.api_key = "";
        }
        return sanitized;
      }

      // Obtiene los parámetros efectivos de OCR aplicando saneamiento
      function getActiveOcrSettings() {
        if (!state.ocrProvider) {
          return { provider: "", endpoint: "", key: "" };
        }
        const params = ensureOcrParameters(state.ocrProvider);
        if (!state.settings.developerMode) {
          return { provider: state.ocrProvider, endpoint: "", key: "" };
        }
        return {
          provider: state.ocrProvider,
          endpoint: (params.endpoint || "").trim(),
          key: (params.key || "").trim(),
        };
      }

      // Intenta convertir cualquier entrada a número de punto flotante
      function parseNumeric(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const parsed = Number.parseFloat(String(value));
        return Number.isNaN(parsed) ? null : parsed;
      }

      // Garantiza que existan parámetros para el proveedor LLM indicado
      function ensureLlmParameters(provider) {
        if (!provider) {
          return state.llmParameters[state.llmProvider] || {};
        }
        if (!state.llmParameters[provider]) {
          state.llmParameters[provider] =
            provider === "api"
              ? {
                  model: "",
                  temperature: 1,
                  temperature_enabled: false,
                  top_p: 1,
                  top_p_enabled: false,
                  reasoning_effort: "minimal",
                  reasoning_effort_enabled: true,
                  frequency_penalty: 0,
                  frequency_penalty_enabled: false,
                  presence_penalty: 0,
                  presence_penalty_enabled: false,
                  api_key: "",
                }
              : {
                  model: "",
                  temperature: 1,
                  temperature_enabled: false,
                  top_p: 1,
                  top_p_enabled: false,
                  reasoning_effort: "minimal",
                  reasoning_effort_enabled: true,
                  frequency_penalty: 0,
                  frequency_penalty_enabled: false,
                  presence_penalty: 0,
                  presence_penalty_enabled: false,
                };
        }
        const params = state.llmParameters[provider];
        if (!Number.isFinite(params.temperature)) {
          params.temperature = 1;
        }
        if (typeof params.temperature_enabled !== "boolean") {
          params.temperature_enabled = false;
        }
        if (!Number.isFinite(params.top_p)) {
          params.top_p = 1;
        }
        if (typeof params.top_p_enabled !== "boolean") {
          params.top_p_enabled = false;
        }
        if (typeof params.reasoning_effort !== "string") {
          params.reasoning_effort = "minimal";
        }
        if (typeof params.reasoning_effort_enabled !== "boolean") {
          params.reasoning_effort_enabled = true;
        }
        if (!Number.isFinite(params.frequency_penalty)) {
          params.frequency_penalty = 0;
        }
        if (typeof params.frequency_penalty_enabled !== "boolean") {
          params.frequency_penalty_enabled = false;
        }
        if (!Number.isFinite(params.presence_penalty)) {
          params.presence_penalty = 0;
        }
        if (typeof params.presence_penalty_enabled !== "boolean") {
          params.presence_penalty_enabled = false;
        }
        if (provider === "api" && typeof params.api_key !== "string") {
          params.api_key = "";
        }
        return params;
      }

      // Garantiza que existan parámetros almacenados para el proveedor OCR dado.
      function ensureOcrParameters(provider) {
        if (!provider) {
          return { endpoint: "", key: "" };
        }
        if (!state.ocrParameters[provider]) {
          state.ocrParameters[provider] = { endpoint: "", key: "" };
        }
        const params = state.ocrParameters[provider];
        if (typeof params.endpoint !== "string") {
          params.endpoint = "";
        }
        if (typeof params.key !== "string") {
          params.key = "";
        }
        return params;
      }

      // Sincroniza el estado habilitado y el valor de un control numérico.
      function setNumericFieldState(input, toggle, enabled) {
        if (toggle) {
          toggle.checked = !!enabled;
        }
        if (input) {
          input.disabled = !enabled;
          const field = input.closest(".llm-field");
          if (field) {
            field.classList.toggle("is-disabled", !enabled);
          }
        } else if (toggle) {
          const field = toggle.closest(".llm-field");
          if (field) {
            field.classList.toggle("is-disabled", !enabled);
          }
        }
      }

      // Actualiza los controles del formulario según el proveedor LLM activo.
      function refreshLlmSettings(provider) {
        if (!llmSettingsContainer) {
          return;
        }
        const targetProvider = provider || state.llmProvider;
        llmSettingsSections.forEach((section) => {
          const sectionProvider = section.getAttribute(
            "data-llm-provider-settings"
          );
          const isActive = sectionProvider === targetProvider;
          section.hidden = !isActive;
          section.setAttribute("aria-hidden", String(!isActive));
        });
        const params = ensureLlmParameters(targetProvider);
        const modelInput = llmModelInputs[targetProvider];
        if (modelInput && modelInput.value !== params.model) {
          modelInput.value = params.model ?? "";
        }
        const temperatureInput = llmTemperatureInputs[targetProvider];
        const temperatureToggle = llmTemperatureToggles[targetProvider];
        if (temperatureInput) {
          const value = Number.isFinite(params.temperature)
            ? params.temperature
            : 1;
          temperatureInput.value = String(value);
        }
        setNumericFieldState(
          temperatureInput,
          temperatureToggle,
          params.temperature_enabled === true
        );
        const topPInput = llmTopPInputs[targetProvider];
        const topPToggle = llmTopPToggles[targetProvider];
        if (topPInput) {
          const value = Number.isFinite(params.top_p) ? params.top_p : 1;
          topPInput.value = String(value);
        }
        setNumericFieldState(
          topPInput,
          topPToggle,
          params.top_p_enabled === true
        );
        const reasoningInput = llmReasoningInputs[targetProvider];
        const reasoningToggle = llmReasoningToggles[targetProvider];
        if (reasoningInput) {
          const value = params.reasoning_effort ?? "minimal";
          reasoningInput.value = value;
        }
        setNumericFieldState(
          reasoningInput,
          reasoningToggle,
          params.reasoning_effort_enabled === true
        );
        const frequencyInput = llmFrequencyInputs[targetProvider];
        const frequencyToggle = llmFrequencyToggles[targetProvider];
        if (frequencyInput) {
          const value = Number.isFinite(params.frequency_penalty)
            ? params.frequency_penalty
            : 0;
          frequencyInput.value = String(value);
        }
        setNumericFieldState(
          frequencyInput,
          frequencyToggle,
          params.frequency_penalty_enabled === true
        );
        const presenceInput = llmPresenceInputs[targetProvider];
        const presenceToggle = llmPresenceToggles[targetProvider];
        if (presenceInput) {
          const value = Number.isFinite(params.presence_penalty)
            ? params.presence_penalty
            : 0;
          presenceInput.value = String(value);
        }
        setNumericFieldState(
          presenceInput,
          presenceToggle,
          params.presence_penalty_enabled === true
        );
        if (targetProvider === "api" && llmApiKeyInput) {
          llmApiKeyInput.value = params.api_key ?? "";
        }
      }

      // Refresca los campos relacionados al proveedor OCR seleccionado.
      function refreshOcrSettings(provider) {
        if (!ocrSettingsContainer) {
          return;
        }
        const targetProvider = provider ?? state.ocrProvider;
        if (
          ocrProviderSelect &&
          ocrProviderSelect.value !== (targetProvider || "")
        ) {
          ocrProviderSelect.value = targetProvider || "";
        }
        ocrSettingsSections.forEach((section) => {
          const sectionProvider = section.getAttribute("data-ocr-provider");
          const isActive = sectionProvider === targetProvider && !!sectionProvider;
          section.hidden = !isActive;
          section.setAttribute("aria-hidden", String(!isActive));
          if (!isActive || !sectionProvider) {
            return;
          }
          const params = ensureOcrParameters(sectionProvider);
          const inputs = ocrInputs[sectionProvider] || {};
          if (inputs.endpoint) {
            const nextValue = params.endpoint || "";
            if (inputs.endpoint.value !== nextValue) {
              inputs.endpoint.value = nextValue;
            }
          }
          if (inputs.key) {
            const nextValue = params.key || "";
            if (inputs.key.value !== nextValue) {
              inputs.key.value = nextValue;
            }
          }
        });
      }

      // Asocia los eventos de los controles de modelo de lenguaje al estado global.
      function bindLlmInputs() {
        Object.keys(state.llmParameters).forEach((provider) =>
          ensureLlmParameters(provider)
        );
        Object.entries(llmModelInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.model = input.value.trim();
          });
        });

        Object.entries(llmTemperatureInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            const min = parseNumeric(input.min);
            const max = parseNumeric(input.max);
            let value = parseNumeric(input.value);
            if (value === null) {
              value = params.temperature ?? 1;
            } else {
              if (min !== null) {
                value = Math.max(min, value);
              }
              if (max !== null) {
                value = Math.min(max, value);
              }
            }
            params.temperature = value;
            input.value = String(value);
          });
        });

        Object.entries(llmTopPInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            const min = parseNumeric(input.min);
            const max = parseNumeric(input.max);
            let value = parseNumeric(input.value);
            if (value === null) {
              value = params.top_p ?? 1;
            } else {
              if (min !== null) {
                value = Math.max(min, value);
              }
              if (max !== null) {
                value = Math.min(max, value);
              }
            }
            params.top_p = value;
            input.value = String(value);
          });
        });

        Object.entries(llmReasoningInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            const value = String(input.value || "").toLowerCase();
            const normalized = REASONING_EFFORT_VALUES.has(value)
              ? value
              : "minimal";
            if (!REASONING_EFFORT_VALUES.has(value)) {
              input.value = "minimal";
            }
            params.reasoning_effort = normalized;
          });
        });

        Object.entries(llmFrequencyInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            const min = parseNumeric(input.min);
            const max = parseNumeric(input.max);
            let value = parseNumeric(input.value);
            if (value === null) {
              value = params.frequency_penalty ?? 0;
            } else {
              if (min !== null) {
                value = Math.max(min, value);
              }
              if (max !== null) {
                value = Math.min(max, value);
              }
            }
            params.frequency_penalty = value;
            input.value = String(value);
          });
        });

        Object.entries(llmPresenceInputs).forEach(([provider, input]) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            const min = parseNumeric(input.min);
            const max = parseNumeric(input.max);
            let value = parseNumeric(input.value);
            if (value === null) {
              value = params.presence_penalty ?? 0;
            } else {
              if (min !== null) {
                value = Math.max(min, value);
              }
              if (max !== null) {
                value = Math.min(max, value);
              }
            }
            params.presence_penalty = value;
            input.value = String(value);
          });
        });

        Object.entries(llmTemperatureToggles).forEach(([provider, toggle]) => {
          if (!toggle) {
            return;
          }
          const input = llmTemperatureInputs[provider];
          toggle.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.temperature_enabled = toggle.checked;
            setNumericFieldState(input, toggle, params.temperature_enabled);
          });
        });

        Object.entries(llmTopPToggles).forEach(([provider, toggle]) => {
          if (!toggle) {
            return;
          }
          const input = llmTopPInputs[provider];
          toggle.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.top_p_enabled = toggle.checked;
            setNumericFieldState(input, toggle, params.top_p_enabled);
          });
        });

        Object.entries(llmReasoningToggles).forEach(([provider, toggle]) => {
          if (!toggle) {
            return;
          }
          const input = llmReasoningInputs[provider];
          toggle.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.reasoning_effort_enabled = toggle.checked;
            setNumericFieldState(
              input,
              toggle,
              params.reasoning_effort_enabled
            );
          });
        });

        Object.entries(llmFrequencyToggles).forEach(([provider, toggle]) => {
          if (!toggle) {
            return;
          }
          const input = llmFrequencyInputs[provider];
          toggle.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.frequency_penalty_enabled = toggle.checked;
            setNumericFieldState(input, toggle, params.frequency_penalty_enabled);
          });
        });

        Object.entries(llmPresenceToggles).forEach(([provider, toggle]) => {
          if (!toggle) {
            return;
          }
          const input = llmPresenceInputs[provider];
          toggle.addEventListener("change", () => {
            const params = ensureLlmParameters(provider);
            params.presence_penalty_enabled = toggle.checked;
            setNumericFieldState(input, toggle, params.presence_penalty_enabled);
          });
        });

        if (llmApiKeyInput) {
          llmApiKeyInput.addEventListener("input", () => {
            const params = ensureLlmParameters("api");
            params.api_key = llmApiKeyInput.value.trim();
          });
        }
      }

      // Conecta los campos de OCR con el estado y los toggles disponibles.
      function bindOcrInputs() {
        if (ocrProviderSelect) {
          ocrProviderSelect.addEventListener("change", (event) => {
            state.ocrProvider = event.target.value;
            refreshOcrSettings(state.ocrProvider);
          });
        }
        Object.entries(ocrInputs).forEach(([provider, inputs]) => {
          if (!inputs) {
            return;
          }
          ensureOcrParameters(provider);
          if (inputs.endpoint) {
            inputs.endpoint.addEventListener("input", () => {
              const params = ensureOcrParameters(provider);
              params.endpoint = inputs.endpoint.value.trim();
            });
          }
          if (inputs.key) {
            inputs.key.addEventListener("input", () => {
              const params = ensureOcrParameters(provider);
              params.key = inputs.key.value.trim();
            });
          }
        });
      }

      // Activa elementos exclusivos para desarrolladores y ajusta la vista.
      function applyDeveloperMode(enabled) {
        document.body.classList.toggle("developer-mode", enabled);
        developerBadge.hidden = !enabled;
        if (llmProviderRow) {
          llmProviderRow.hidden = !enabled;
          llmProviderRow.setAttribute("aria-hidden", String(!enabled));
          if (enabled) {
            if (llmProviderSelect) {
              llmProviderSelect.value = state.llmProvider;
            }
          } else {
            state.llmProvider = "api";
            if (llmProviderSelect) {
              llmProviderSelect.value = "api";
            }
          }
        }
        developerOnlyElements.forEach((element) => {
          if (!element) {
            return;
          }
          element.hidden = !enabled;
          element.setAttribute("aria-hidden", String(!enabled));
        });
        if (!enabled) {
          updateRetrainStatus("", null);
        }
        if (llmSettingsContainer) {
          llmSettingsContainer.hidden = !enabled;
          llmSettingsContainer.setAttribute("aria-hidden", String(!enabled));
          if (enabled) {
            refreshLlmSettings(state.llmProvider);
          }
        }
        if (ocrSettingsContainer) {
          ocrSettingsContainer.hidden = !enabled;
          ocrSettingsContainer.setAttribute("aria-hidden", String(!enabled));
          if (enabled) {
            refreshOcrSettings(state.ocrProvider);
          }
        }
      }

      // Propaga la configuración almacenada a los controles del panel de ajustes.
      function syncSettingsControls() {
        autoClearToggle.checked = state.settings.autoClear;
        themeSelect.value = state.settings.theme;
        developerToggle.checked = state.settings.developerMode;
      }

      // Muestra el panel lateral de configuración y registra el foco previo.
      function openSettingsPanel() {
        if (settingsPanel.getAttribute("aria-hidden") === "false") {
          return;
        }
        syncSettingsControls();
        lastSettingsTrigger = document.activeElement;
        settingsPanel.setAttribute("aria-hidden", "false");
        settingsBackdrop.hidden = false;
        settingsButton.setAttribute("aria-expanded", "true");
        settingsPanel.focus({ preventScroll: true });
      }

      // Oculta el panel de configuración restaurando el foco original.
      function closeSettingsPanel() {
        if (settingsPanel.getAttribute("aria-hidden") === "true") {
          return;
        }
        settingsPanel.setAttribute("aria-hidden", "true");
        settingsBackdrop.hidden = true;
        settingsButton.setAttribute("aria-expanded", "false");
        if (lastSettingsTrigger && typeof lastSettingsTrigger.focus === "function") {
          lastSettingsTrigger.focus({ preventScroll: true });
        }
        lastSettingsTrigger = null;
      }

      // Gestiona la visibilidad del botón que reabre el panel de entrada.
      function setShowPanelButtonVisibility(visible) {
        showInputPanelButton.toggleAttribute("hidden", !visible);
        showInputPanelButton.setAttribute("aria-hidden", String(!visible));
      }

      // Elimina cualquier vista previa acoplada que utilice un recurso remoto.
      function clearDockedPreviewUrl() {
        if (state.dockedPreviewUrl) {
          URL.revokeObjectURL(state.dockedPreviewUrl);
          state.dockedPreviewUrl = null;
        }
      }

      // Presenta un mensaje contextual en el panel de vista previa acoplado.
      function setDockedPreviewMessage(message) {
        if (!dockedPreviewContent) {
          return;
        }
        clearDockedPreviewUrl();
        const placeholder = document.createElement("p");
        placeholder.className = "preview-placeholder";
        placeholder.textContent = message;
        dockedPreviewContent.replaceChildren(placeholder);
        clearMissingHighlightNotice(dockedPreviewContent);
        if (dockedPreviewHint) {
          dockedPreviewHint.hidden = true;
          dockedPreviewHint.textContent = "";
        }
      }

      // Borra la notificación que indica campos sin resaltado disponible.
      function clearMissingHighlightNotice(container) {
        if (!container) {
          return;
        }
        container.classList.remove("preview-content--missing");
        const existing = container.querySelector(".preview-missing-highlight");
        if (existing) {
          existing.remove();
        }
      }

      // Actualiza el mensaje cuando faltan resaltados para ciertos campos.
      function updateMissingHighlightNotice(container, visibleHighlights, options = {}) {
        if (!container) {
          return;
        }
        const mode = options.mode || "text";
        if (mode !== "text") {
          clearMissingHighlightNotice(container);
          return;
        }
        const missing = state.missingHighlight;
        const hasVisible = Array.isArray(visibleHighlights) && visibleHighlights.length > 0;
        if (!missing || hasVisible) {
          clearMissingHighlightNotice(container);
          return;
        }
        let notice = container.querySelector(".preview-missing-highlight");
        if (!notice) {
          notice = document.createElement("div");
          notice.className = "preview-missing-highlight";
        }
        const label = missing.label || missing.key || "este campo";
        notice.replaceChildren();
        notice.append("No se encontraron coincidencias exactas para ");
        const emphasis = document.createElement("strong");
        emphasis.textContent = `“${label}”`;
        notice.appendChild(emphasis);
        notice.append(".");
        const hint = container.querySelector(".preview-hint");
        if (hint && hint.parentElement === container) {
          container.insertBefore(notice, hint.nextSibling);
        } else {
          container.prepend(notice);
        }
        container.classList.add("preview-content--missing");
      }

      // Reinicia el panel acoplado eliminando datos y mensajes temporales.
      function resetDockedPreview() {
        setDockedPreviewMessage("Selecciona “Ver contenido” para mostrarlo aquí.");
      }

      // Determina si un resultado posee una vista previa de archivo utilizable.
      function isFilePreviewAvailable(entry) {
        if (!entry) {
          return false;
        }
        const hasFile = entry.file && typeof entry.file === "object";
        const hasCategory = typeof entry.category === "string" && entry.category.trim() !== "";
        return Boolean(hasFile && hasCategory);
      }

      // Activa o desactiva la visualización acoplada manteniendo el estado.
      function setPreviewDocked(enabled) {
        isPreviewDocked = enabled;
        workspace.classList.toggle("workspace--with-preview", enabled);
        if (!previewPanel) {
          return;
        }
        if (enabled) {
          previewPanel.hidden = false;
          previewPanel.setAttribute("aria-hidden", "false");
          resetDockedPreview();
          if (state.results.length > 0) {
            const safeIndex = Math.max(
              0,
              Math.min(state.currentIndex, state.results.length - 1)
            );
            const entry = state.results[safeIndex];
            if (entry) {
              state.currentHighlights = getEntryHighlights(entry);
              updatePreviewModeControls(entry);
              updateViewContentButton(entry);
              renderCurrentPreview(entry);
            } else {
              setDockedPreviewMessage("No hay contenido disponible.");
            }
          }
        } else {
          previewPanel.hidden = true;
          previewPanel.setAttribute("aria-hidden", "true");
          resetDockedPreview();
        }
      }

      // Oculta el panel de entrada para maximizar el área de resultados.
      function collapseInputPanel() {
        if (workspace.classList.contains("workspace--input-hidden")) {
          return;
        }
        workspace.classList.add("workspace--input-hidden");
        inputPanel.setAttribute("aria-hidden", "true");
        inputPanelBody.setAttribute("aria-hidden", "true");
        setShowPanelButtonVisibility(true);
        setPreviewDocked(true);
        hideInputPanelButton.setAttribute("aria-pressed", "true");
        showInputPanelButton.focus({ preventScroll: true });
      }

      // Restaura el panel de entrada cuando el usuario solicita editar.
      function expandInputPanel() {
        if (!workspace.classList.contains("workspace--input-hidden")) {
          return;
        }
        workspace.classList.remove("workspace--input-hidden");
        inputPanel.removeAttribute("aria-hidden");
        inputPanelBody.removeAttribute("aria-hidden");
        setShowPanelButtonVisibility(false);
        setPreviewDocked(false);
        hideInputPanelButton.setAttribute("aria-pressed", "false");
        hideInputPanelButton.focus({ preventScroll: true });
      }

      // Limpia los indicadores de progreso del procesamiento masivo.
      function resetMultiProgress() {
        multiProgress.hidden = true;
        multiProgressTrack.setAttribute("aria-valuenow", "0");
        multiProgressTrack.setAttribute("aria-valuemax", "1");
        multiProgressBar.style.width = "0%";
        multiProgressText.textContent = "0 de 0 facturas";
        multiProgressPercent.textContent = "0%";
      }

      // Inicializa el estado visual del progreso para múltiples archivos.
      function showMultiProgress(total) {
        multiProgress.hidden = false;
        multiProgressTrack.setAttribute("aria-valuemin", "0");
        multiProgressTrack.setAttribute("aria-valuemax", String(total));
        multiProgressTrack.setAttribute("aria-valuenow", "0");
        multiProgressBar.style.width = "0%";
        multiProgressText.textContent = `0 de ${total} facturas`;
        multiProgressPercent.textContent = "0%";
      }

      // Actualiza las barras e indicadores del progreso multiarchivo.
      function updateMultiProgress(current, total) {
        multiProgressTrack.setAttribute("aria-valuenow", String(current));
        const percentage = total === 0 ? 0 : Math.round((current / total) * 100);
        multiProgressBar.style.width = `${percentage}%`;
        multiProgressText.textContent = `${current} de ${total} facturas`;
        multiProgressPercent.textContent = `${percentage}%`;
      }

      // Cierra el modal de vista previa y restaura el foco apropiado.
      function closePreviewModal() {
        if (previewModal.hidden) {
          return;
        }
        const focusTarget = lastFocusedElement;
        previewModal.hidden = true;
        previewModal.setAttribute("aria-hidden", "true");
        if (state.modalPreviewUrl) {
          URL.revokeObjectURL(state.modalPreviewUrl);
          state.modalPreviewUrl = null;
        }
        previewModalContent.innerHTML = "";
        clearMissingHighlightNotice(previewModalContent);
        document.body.classList.remove("modal-open");
        if (focusTarget && typeof focusTarget.focus === "function") {
          focusTarget.focus();
        }
        lastFocusedElement = null;
      }

      // Genera el contenido HTML para la vista previa modal de un archivo.
      function renderModalPreview(file, category) {
        previewModalContent.innerHTML = "";
        clearMissingHighlightNotice(previewModalContent);
        if (!file || !category) {
          const message = document.createElement("p");
          message.style.padding = "1.25rem";
          message.textContent = "No hay vista previa disponible.";
          previewModalContent.appendChild(message);
          return;
        }

        if (category === "image" || category === "pdf") {
          if (state.modalPreviewUrl) {
            URL.revokeObjectURL(state.modalPreviewUrl);
            state.modalPreviewUrl = null;
          }
          const url = URL.createObjectURL(file);
          state.modalPreviewUrl = url;

          if (category === "image") {
            const img = document.createElement("img");
            img.src = url;
            img.alt = "Vista previa ampliada de la imagen subida";
            previewModalContent.appendChild(img);
          } else {
            const iframe = document.createElement("iframe");
            iframe.src = url;
            iframe.title = "Vista previa ampliada del PDF";
            previewModalContent.appendChild(iframe);
          }
        } else {
          if (state.modalPreviewUrl) {
            URL.revokeObjectURL(state.modalPreviewUrl);
            state.modalPreviewUrl = null;
          }
          const placeholder = document.createElement("p");
          placeholder.style.padding = "1.25rem";
          placeholder.textContent = "Cargando vista previa...";
          previewModalContent.appendChild(placeholder);
          const reader = new FileReader();
          reader.onload = () => {
            const text = reader.result || "";
            previewModalContent.innerHTML = "";
            const pre = document.createElement("pre");
            pre.textContent = String(text).slice(0, 20000);
            previewModalContent.appendChild(pre);
          };
          reader.readAsText(file, "utf-8");
        }
      }

      // Muestra el modal con la vista previa ya renderizada.
      function showModalPreview(file, category) {
        if (!file || !category) {
          return;
        }
        renderModalPreview(file, category);
        openPreviewModal();
      }

      // Abre el modal asegurando que el enfoque sea coherente.
      function openPreviewModal() {
        lastFocusedElement = document.activeElement;
        previewModal.hidden = false;
        previewModal.setAttribute("aria-hidden", "false");
        document.body.classList.add("modal-open");
        previewModalClose.focus();
      }

      previewModalClose.addEventListener("click", () => {
        closePreviewModal();
      });

      previewModal.addEventListener("click", (event) => {
        if (event.target === previewModal) {
          closePreviewModal();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key !== "Escape") {
          return;
        }
        if (!previewModal.hidden) {
          event.preventDefault();
          closePreviewModal();
          return;
        }
        if (settingsPanel.getAttribute("aria-hidden") === "false") {
          event.preventDefault();
          closeSettingsPanel();
        }
      });

      bindLlmInputs();
      bindOcrInputs();
      refreshLlmSettings(state.llmProvider);
      refreshOcrSettings(state.ocrProvider);

      setOcrToggleVisibility(false);
      setVisionToggleVisibility(false);
      updateTestingSampleButtonsState();
      resetMultiProgress();

      hideInputPanelButton.addEventListener("click", () => {
        collapseInputPanel();
      });

      showInputPanelButton.addEventListener("click", () => {
        expandInputPanel();
      });

      settingsButton.addEventListener("click", () => {
        openSettingsPanel();
      });

      closeSettingsButton.addEventListener("click", () => {
        closeSettingsPanel();
      });

      settingsBackdrop.addEventListener("click", () => {
        closeSettingsPanel();
      });

      autoClearToggle.addEventListener("change", (event) => {
        state.settings.autoClear = event.target.checked;
      });

      themeSelect.addEventListener("change", (event) => {
        state.settings.theme = event.target.value;
        applyTheme(state.settings.theme);
      });

      developerToggle.addEventListener("change", (event) => {
        state.settings.developerMode = event.target.checked;
        applyDeveloperMode(state.settings.developerMode);
      });

      if (llmProviderSelect) {
        llmProviderSelect.addEventListener("change", (event) => {
          const value = event.target.value === "local" ? "local" : "api";
          state.llmProvider = value;
          refreshLlmSettings(state.llmProvider);
        });
      }

      applyTheme(state.settings.theme);
      applyDeveloperMode(state.settings.developerMode);
      setShowPanelButtonVisibility(false);

      multiFileInput.setAttribute("accept", ACCEPT_STRING);

      // Vacía la cola de archivos seleccionados y estados asociados.
      function resetMultiFiles() {
        state.multiFiles = [];
        state.multiCategory = null;
        state.multiUseOcr = false;
        state.multiUseVision = false;
        multiFileInput.value = "";
        multiDetails.hidden = true;
        multiEmptyState.hidden = true;
        multiFileList.innerHTML = "";
        multiTypeLabel.textContent = "—";
        setOcrToggleVisibility(false);
        setVisionToggleVisibility(false);
        resetMultiProgress();
        if (multiPdfOcrToggle) {
          multiPdfOcrToggle.checked = false;
        }
        if (testingPdfOcrToggle) {
          testingPdfOcrToggle.checked = false;
        }
        updateTestingSampleButtonsState();
        if (testingSelectionList) {
          testingSelectionList.innerHTML = "";
          testingSelectionList.hidden = true;
        }
        if (testingSelectionEmpty) {
          testingSelectionEmpty.hidden = false;
        }
      }

      // Actualiza el mensaje de estado principal indicando errores o progreso.
      function setStatus(message, isError = false) {
        statusMessage.textContent = message;
        statusMessage.classList.toggle("error", Boolean(isError));
      }

      // Marca el botón activo entre los modos de procesamiento.
      function setActiveModeButton(button, isActive) {
        if (!button) {
          return;
        }
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-selected", String(isActive));
      }

      // Cambia entre modo texto y modo múltiple actualizando la interfaz.
      function switchMode(mode) {
        if (mode === state.mode) return;
        state.mode = mode;
        const isTextMode = mode === "text";
        const isMultiMode = mode === "multi";
        const isTestingMode = mode === "testing";
        textMode.hidden = !isTextMode;
        multiMode.hidden = !isMultiMode;
        if (testingMode) {
          testingMode.hidden = !isTestingMode;
        }
        setActiveModeButton(textModeButton, isTextMode);
        setActiveModeButton(multiModeButton, isMultiMode);
        setActiveModeButton(testingModeButton, isTestingMode);
        const hasOcrBatch =
          (state.multiCategory === "pdf" || state.multiCategory === "image") &&
          state.multiFiles.length > 0;
        setOcrToggleVisibility(hasOcrBatch);
        const hasVisionBatch = hasOcrBatch;
        setVisionToggleVisibility(hasVisionBatch);
        updateTestingSampleButtonsState();
        if (hasOcrBatch) {
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = state.multiUseOcr;
          }
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = state.multiUseOcr;
          }
        }
        const inputHidden = workspace.classList.contains("workspace--input-hidden");
        if (isTextMode) {
          resetMultiFiles();
          if (!inputHidden) {
            plainText.focus();
          }
        } else if (isMultiMode) {
          if (!inputHidden) {
            plainText.value = "";
            multiDropZone.focus();
          }
        } else if (isTestingMode) {
          if (!inputHidden) {
            plainText.value = "";
            const firstAddButton = testingSamplesList
              ? testingSamplesList.querySelector(".testing-sample__add")
              : null;
            if (firstAddButton) {
              firstAddButton.focus();
            }
          }
        }
        setStatus("");
      }

      textModeButton.addEventListener("click", () => switchMode("text"));
      multiModeButton.addEventListener("click", () => switchMode("multi"));
      if (testingModeButton) {
        testingModeButton.addEventListener("click", () => switchMode("testing"));
      }

      // Infere la categoría de un archivo según su extensión y tipo MIME.
      function detectCategory(file) {
        const extension = (file.name.split(".").pop() || "").toLowerCase();
        const mime = (file.type || "").toLowerCase();
        if (mime.startsWith("image/")) {
          return "image";
        }
        for (const [key, info] of Object.entries(SUPPORTED_TYPES)) {
          if (info.extensions.includes(extension)) {
            return key;
          }
        }
        if (mime === "application/pdf") {
          return "pdf";
        }
        return null;
      }

      function formatTypeLabel(category, options = {}) {
        const info = SUPPORTED_TYPES[category];
        const baseLabel = info ? info.label : category || "—";
        const flags = [];
        if (options.useOcr) {
          flags.push("OCR");
        }
        if (options.useVision) {
          flags.push("Visión");
        }
        if (!flags.length) {
          return baseLabel;
        }
        return `${baseLabel} (${flags.join(", ")})`;
      }

      // Redibuja la lista de archivos seleccionados con su estado.
      function renderMultiList() {
        updateTestingSampleButtonsState();
        if (!state.multiFiles.length) {
          resetMultiFiles();
          return;
        }
        multiDetails.hidden = false;
        multiEmptyState.hidden = true;
        const isPdfBatch =
          state.multiCategory === "pdf" && state.multiFiles.length > 0;
        const isImageBatch =
          state.multiCategory === "image" && state.multiFiles.length > 0;
        const isOcrBatch = isPdfBatch || isImageBatch;
        setOcrToggleVisibility(isOcrBatch);
        setVisionToggleVisibility(isOcrBatch);
        if (isOcrBatch) {
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = state.multiUseOcr;
          }
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = state.multiUseOcr;
          }
        } else {
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = false;
          }
        }
        const multiLabel = formatTypeLabel(state.multiCategory, {
          useOcr:
            (state.multiCategory === "pdf" || state.multiCategory === "image") &&
            state.multiUseOcr,
          useVision: isOcrBatch && state.multiUseVision,
        });
        multiTypeLabel.textContent = multiLabel;
        multiFileList.innerHTML = "";
        state.multiFiles.forEach((entry, index) => {
          const item = document.createElement("li");
          item.className = "multi-file-item";
          const info = document.createElement("span");
          const name = document.createElement("strong");
          name.textContent = entry.file.name;
          const type = document.createElement("small");
          type.textContent = formatTypeLabel(entry.category, {
            useOcr:
              (entry.category === "pdf" || entry.category === "image") &&
              state.multiUseOcr,
            useVision:
              (entry.category === "pdf" || entry.category === "image") &&
              state.multiUseVision,
          });
          info.appendChild(name);
          info.appendChild(type);
          const actions = document.createElement("div");
          actions.className = "multi-file-actions";

          const viewButton = document.createElement("button");
          viewButton.type = "button";
          viewButton.textContent = "Ver";
          viewButton.className = "preview-action";
          viewButton.setAttribute(
            "aria-label",
            `Ver ${entry.file.name} en pantalla completa`
          );
          viewButton.addEventListener("click", () => {
            showModalPreview(entry.file, entry.category);
          });

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.textContent = "×";
          removeButton.className = "remove-button";
          removeButton.setAttribute(
            "aria-label",
            `Eliminar ${entry.file.name} de la lista`
          );
          removeButton.addEventListener("click", () => {
            removeMultiEntry(index);
          });

          actions.appendChild(viewButton);
          actions.appendChild(removeButton);

          item.appendChild(info);
          item.appendChild(actions);
          multiFileList.appendChild(item);
        });
        updateTestingSelection();
      }

      function updateTestingSampleButtonsState() {
        if (!testingSamplesList) {
          return;
        }
        const disableButtons = state.multiFiles.length >= 1;
        testingSamplesList
          .querySelectorAll(".testing-sample__add")
          .forEach((button) => {
            button.disabled = disableButtons;
            button.setAttribute("aria-disabled", String(disableButtons));
          });
      }

      function updateTestingSelection() {
        if (!testingSelectionList || !testingSelectionEmpty) {
          return;
        }
        updateTestingSampleButtonsState();
        testingSelectionList.innerHTML = "";
        if (!state.multiFiles.length) {
          testingSelectionList.hidden = true;
          testingSelectionEmpty.hidden = false;
          return;
        }
        testingSelectionEmpty.hidden = true;
        testingSelectionList.hidden = false;
        state.multiFiles.forEach((entry, index) => {
          const item = document.createElement("li");
          item.className = "testing-selection__item";

          const info = document.createElement("div");
          info.className = "testing-selection__info";
          const name = document.createElement("strong");
          name.textContent = entry.file.name;
          const typeText = document.createElement("span");
          typeText.textContent = formatTypeLabel(entry.category, {
            useOcr:
              (entry.category === "pdf" || entry.category === "image") &&
              state.multiUseOcr,
            useVision:
              (entry.category === "pdf" || entry.category === "image") &&
              state.multiUseVision,
          });
          info.appendChild(name);
          info.appendChild(typeText);

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.className = "testing-selection__remove";
          removeButton.textContent = "Quitar";
          removeButton.setAttribute(
            "aria-label",
            `Quitar ${entry.file.name} de la lista de pruebas`
          );
          removeButton.addEventListener("click", () => {
            removeMultiEntry(index);
          });

          item.appendChild(info);
          item.appendChild(removeButton);
          testingSelectionList.appendChild(item);
        });
      }

      function removeMultiEntry(index) {
        if (index < 0 || index >= state.multiFiles.length) {
          return;
        }
        state.multiFiles.splice(index, 1);
        if (!state.multiFiles.length) {
          state.multiCategory = null;
          state.multiUseOcr = false;
          state.multiUseVision = false;
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = false;
          }
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = false;
          }
        }
        renderMultiList();
      }

      // Procesa un archivo individual añadido al modo múltiple.
      function handleMultiSelection(file, options = {}) {
        const category = detectCategory(file);
        if (!category) {
          setStatus(`El archivo ${file.name} no es de un formato admitido.`, true);
          return;
        }
        if (state.multiCategory && state.multiCategory !== category) {
          setStatus(
            "Todos los archivos deben ser del mismo tipo para el procesamiento en lote.",
            true
          );
          return;
        }
        state.multiCategory = category;
        if (category !== "pdf" && category !== "image") {
          setOcrToggleVisibility(false);
        }
        const wasEmpty = state.multiFiles.length === 0;
        const uploadedAt = Date.now();
        state.multiFiles.push({ file, category, uploadedAt });
        if (category === "image") {
          if (wasEmpty) {
            state.multiUseVision = true;
            state.multiUseOcr = true;
          }
        } else if (wasEmpty) {
          state.multiUseVision = false;
          state.multiUseOcr = false;
        }
        if (
          (category === "pdf" || category === "image") &&
          typeof options.useOcr === "boolean"
        ) {
          if (options.useOcr) {
            state.multiUseOcr = true;
          } else if (wasEmpty) {
            state.multiUseOcr = false;
          }
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = state.multiUseOcr;
          }
        }
        renderMultiList();
        setStatus("");
      }

      // Integra una colección de archivos al flujo multiarchivo.
      function handleMultiFileList(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        Array.from(fileList).forEach((file) => handleMultiSelection(file));
        multiFileInput.value = "";
      }

      async function addTestingSample(sampleElement) {
        if (!sampleElement) {
          return;
        }
        if (state.mode === "testing" && state.multiFiles.length >= 1) {
          setStatus(
            "Solo puedes agregar un documento de prueba a la vez. Quita el actual antes de continuar.",
            true
          );
          return;
        }
        const url = sampleElement.getAttribute("data-url");
        const filename = sampleElement.getAttribute("data-filename") || "documento";
        const mime = sampleElement.getAttribute("data-mime") || "";
        const requiresOcrAttr = sampleElement.getAttribute("data-requires-ocr");
        if (!url) {
          setStatus("No se encontró la ruta del documento de prueba.", true);
          return;
        }
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`No se pudo cargar ${filename}.`);
          }
          const blob = await response.blob();
          const fileOptions = {};
          if (mime) {
            fileOptions.type = mime;
          } else if (blob.type) {
            fileOptions.type = blob.type;
          }
          const file = new File([blob], filename, fileOptions);
          const selectionOptions = {};
          if (requiresOcrAttr === "true") {
            selectionOptions.useOcr = true;
          } else if (requiresOcrAttr === "false") {
            selectionOptions.useOcr = false;
          }
          handleMultiSelection(file, selectionOptions);
          if (state.mode !== "testing") {
            switchMode("testing");
          }
        } catch (error) {
          console.error(error);
          setStatus(error.message || "No se pudo cargar el documento de prueba.", true);
        }
      }

      multiBrowseButton.addEventListener("click", () => {
        if (state.mode !== "multi") return;
        multiFileInput.click();
      });

      multiFileInput.addEventListener("change", (event) => {
        const files = event.target.files;
        handleMultiFileList(files);
      });

      multiDropZone.addEventListener("click", () => {
        if (state.mode !== "multi") return;
        multiFileInput.click();
      });

      multiDropZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.mode === "multi") {
          multiDropZone.classList.add("dragging");
        }
      });

      ["dragleave", "dragend", "drop"].forEach((eventName) => {
        multiDropZone.addEventListener(eventName, () =>
          multiDropZone.classList.remove("dragging")
        );
      });

      multiDropZone.addEventListener("drop", (event) => {
        event.preventDefault();
        if (state.mode !== "multi") {
          return;
        }
        const { files } = event.dataTransfer;
        handleMultiFileList(files);
      });

      if (multiPdfOcrToggle) {
        multiPdfOcrToggle.addEventListener("change", () => {
          state.multiUseOcr = multiPdfOcrToggle.checked;
          if (testingPdfOcrToggle) {
            testingPdfOcrToggle.checked = state.multiUseOcr;
          }
          renderMultiList();
        });
      }

      if (testingPdfOcrToggle) {
        testingPdfOcrToggle.addEventListener("change", () => {
          state.multiUseOcr = testingPdfOcrToggle.checked;
          if (multiPdfOcrToggle) {
            multiPdfOcrToggle.checked = state.multiUseOcr;
          }
          renderMultiList();
        });
      }

      if (multiVisionToggle) {
        multiVisionToggle.addEventListener("change", () => {
          state.multiUseVision = multiVisionToggle.checked;
          if (testingVisionToggle) {
            testingVisionToggle.checked = state.multiUseVision;
          }
          renderMultiList();
        });
      }

      if (testingVisionToggle) {
        testingVisionToggle.addEventListener("change", () => {
          state.multiUseVision = testingVisionToggle.checked;
          if (multiVisionToggle) {
            multiVisionToggle.checked = state.multiUseVision;
          }
          renderMultiList();
        });
      }

      if (testingSamplesList) {
        testingSamplesList.addEventListener("click", (event) => {
          const addButton = event.target.closest(".testing-sample__add");
          if (!addButton) {
            return;
          }
          const sample = addButton.closest("[data-testing-sample]");
          addTestingSample(sample);
        });
      }

      // Aplana un objeto anidado para facilitar búsquedas por clave.
      function flattenData(data, prefix = "") {
        if (data === null || data === undefined) {
          return { [prefix.slice(0, -1)]: null };
        }
        if (typeof data !== "object") {
          return { [prefix.slice(0, -1)]: data };
        }
        if (Array.isArray(data)) {
          if (!data.length) {
            return { [prefix.slice(0, -1)]: [] };
          }
          const result = {};
          data.forEach((value, index) => {
            Object.entries(flattenData(value, `${prefix}${index}.`)).forEach(
              ([key, val]) => {
                result[key] = val;
              }
            );
          });
          return result;
        }
        const entries = Object.entries(data);
        if (!entries.length) {
          return { [prefix.slice(0, -1)]: {} };
        }
        const result = {};
        entries.forEach(([key, value]) => {
          Object.entries(flattenData(value, `${prefix}${key}.`)).forEach(([child, val]) => {
            result[child] = val;
          });
        });
        return result;
      }

      // Sanitiza cadenas para mostrarlas con seguridad como HTML.
      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      // Escapa valores que serán insertados en atributos HTML.
      function escapeAttribute(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      // Prepara una cadena para ser usada en expresiones regulares.
      function escapeRegExp(value) {
        return String(value).replace(/[\\^$*+?.()|{}\[\]-]/g, "\\$&");
      }

      // Calcula los resaltados que deben mostrarse en la vista previa.
      function computePreviewHighlights(flatData) {
        if (!flatData || typeof flatData !== "object") {
          return [];
        }
        return Object.entries(flatData).reduce((list, [key, value]) => {
          if (value === null || value === undefined) {
            return list;
          }
          const label = key || "(valor)";
          if (typeof value === "string") {
            const trimmed = value.trim();
            if (!trimmed) {
              return list;
            }
            const isNumericLike = /^-?\d+(?:[.,]\d+)?$/.test(trimmed);
            if (trimmed.length < 2 && !isNumericLike) {
              return list;
            }
            list.push({ field: label, value: trimmed });
            return list;
          }
          if (typeof value === "number") {
            const text = String(value);
            if (text) {
              list.push({ field: label, value: text });
            }
            return list;
          }
          if (typeof value === "boolean") {
            list.push({ field: label, value: value ? "true" : "false" });
            return list;
          }
          return list;
        }, []);
      }

      // Genera coincidencias exactas para aplicar resaltados en texto plano.
      function buildHighlightMatches(text, highlights) {
        if (!text || !Array.isArray(highlights) || highlights.length === 0) {
          return [];
        }
        const matches = [];
        highlights.forEach(({ field, value }) => {
          if (!value) {
            return;
          }
          const pattern = new RegExp(escapeRegExp(value), "gi");
          let match;
          while ((match = pattern.exec(text)) !== null) {
            matches.push({
              start: match.index,
              end: match.index + match[0].length,
              field: field || "(valor)",
            });
            if (match.index === pattern.lastIndex) {
              pattern.lastIndex += 1;
            }
          }
        });
        if (!matches.length) {
          return [];
        }
        matches.sort((a, b) => {
          if (a.start === b.start) {
            return b.end - a.end;
          }
          return a.start - b.start;
        });
        const filtered = [];
        let lastEnd = -1;
        matches.forEach((match) => {
          if (match.start >= lastEnd) {
            filtered.push(match);
            lastEnd = match.end;
          }
        });
        return filtered;
      }

      // Unifica el formato de las claves utilizadas en resaltados.
      function normalizeHighlightKey(field) {
        if (field === null || field === undefined) {
          return "";
        }
        return String(field).toLowerCase();
      }

      // Registra que un campo carece de resaltado disponible.
      function setMissingHighlight(field, label) {
        const normalized = field ? normalizeHighlightKey(field) : "";
        const key = normalized || null;
        if (!key) {
          if (state.missingHighlight) {
            state.missingHighlight = null;
            return true;
          }
          return false;
        }
        const safeLabel = typeof label === "string" ? label : "";
        if (
          state.missingHighlight &&
          state.missingHighlight.key === key &&
          state.missingHighlight.label === safeLabel
        ) {
          return false;
        }
        state.missingHighlight = { key, label: safeLabel };
        return true;
      }

      // Elimina la marca de campo sin resaltado cuando se resuelve.
      function clearMissingHighlight(field) {
        if (!state.missingHighlight) {
          return false;
        }
        if (!field) {
          state.missingHighlight = null;
          return true;
        }
        const normalized = normalizeHighlightKey(field);
        if (state.missingHighlight.key === normalized) {
          state.missingHighlight = null;
          return true;
        }
        return false;
      }

      // Obtiene la lista de resaltados actualmente visibles.
      function getVisibleHighlights() {
        if (!Array.isArray(state.currentHighlights) || !state.currentHighlights.length) {
          return [];
        }
        const focusKey = state.highlightFocusKey;
        if (focusKey) {
          return state.currentHighlights.filter(
            ({ field }) => normalizeHighlightKey(field) === focusKey
          );
        }
        const visibility = state.highlightVisibility || {};
        const hasRules = Object.keys(visibility).length > 0;
        if (!hasRules) {
          return state.currentHighlights;
        }
        return state.currentHighlights.filter(({ field }) => {
          const key = normalizeHighlightKey(field);
          if (!key) {
            return true;
          }
          if (Object.prototype.hasOwnProperty.call(visibility, key)) {
            return visibility[key] !== false;
          }
          return true;
        });
      }

      // Controla la visibilidad de un grupo de resaltados relacionados.
      function setGroupHighlightVisibility(fields, visible) {
        if (!Array.isArray(fields) || !fields.length) {
          return;
        }
        if (!state.highlightVisibility || typeof state.highlightVisibility !== "object") {
          state.highlightVisibility = {};
        }
        const visibility = state.highlightVisibility;
        fields.forEach((field) => {
          const key = normalizeHighlightKey(field);
          if (!key) {
            return;
          }
          if (visible) {
            delete visibility[key];
          } else {
            visibility[key] = false;
          }
        });
      }

      // Establece qué campo debe recibir enfoque entre los resaltados.
      function setHighlightFocusKey(field, options = {}) {
        const normalized = field ? normalizeHighlightKey(field) : "";
        const key = normalized || null;
        const allowMissing = Boolean(options.allowMissing);
        if (key && !allowMissing && (!state.highlightIndex || !state.highlightIndex[key])) {
          return false;
        }
        const previousKey = state.highlightFocusKey;
        if (previousKey === key) {
          if (!key && state.missingHighlight) {
            state.missingHighlight = null;
            return true;
          }
          if (!allowMissing) {
            state.missingHighlight = null;
          }
          return false;
        }
        state.highlightFocusKey = key;
        if (!key || !allowMissing) {
          state.missingHighlight = null;
        }
        return true;
      }

      // Actualiza la UI que muestra el estado de cada resaltado.
      function updateHighlightIndicators() {
        if (!resultsContainer) {
          return;
        }
        const fields = resultsContainer.querySelectorAll(".result-field[data-highlight-key]");
        fields.forEach((field) => {
          const key = field.dataset.highlightKey || "";
          if (!key) {
            field.classList.remove(
              "result-field--highlighted",
              "result-field--muted",
              "result-field--focused"
            );
            return;
          }
          const entries =
            state.highlightIndex && state.highlightIndex[key]
              ? state.highlightIndex[key]
              : null;
          const hasHighlight = Array.isArray(entries) && entries.length > 0;
          if (!hasHighlight) {
            field.classList.remove(
              "result-field--highlighted",
              "result-field--muted",
              "result-field--focused"
            );
            field.removeAttribute("data-highlight-key");
            return;
          }
          const hasFocus = Boolean(state.highlightFocusKey);
          const suppressedByVisibility =
            !hasFocus && state.highlightVisibility && state.highlightVisibility[key] === false;
          const isFocused = state.highlightFocusKey === key;
          const suppressedByFocus = hasFocus && !isFocused;
          const shouldHighlight = !suppressedByVisibility && !suppressedByFocus;
          field.classList.toggle("result-field--highlighted", shouldHighlight);
          field.classList.toggle(
            "result-field--muted",
            (suppressedByVisibility || suppressedByFocus) && !isFocused
          );
          field.classList.toggle("result-field--focused", isFocused);
        });
      }

      // Asigna un valor en una estructura plana respetando las claves originales.
      function setValueForFlatKey(entry, key, value) {
        if (!entry || typeof entry !== "object") {
          return;
        }
        if (!entry.data || typeof entry.data !== "object") {
          entry.data = {};
        }
        const rawPath = typeof key === "string" ? key : String(key || "");
        const segments = rawPath.split(".").filter(Boolean);
        if (!segments.length) {
          return;
        }
        let current = entry.data;
        for (let index = 0; index < segments.length; index += 1) {
          const segment = segments[index];
          const isIndex = /^\d+$/.test(segment);
          const isLast = index === segments.length - 1;
          if (isLast) {
            if (isIndex) {
              const targetIndex = Number(segment);
              if (Array.isArray(current)) {
                current[targetIndex] = value;
              } else if (current && typeof current === "object") {
                current[segment] = value;
              }
            } else {
              current[segment] = value;
            }
            markPredictionDirty(entry);
            return;
          }
          const nextSegment = segments[index + 1];
          const nextIsIndex = /^\d+$/.test(nextSegment);
          if (isIndex) {
            const targetIndex = Number(segment);
            if (!Array.isArray(current)) {
              if (current && typeof current === "object") {
                if (!Object.prototype.hasOwnProperty.call(current, segment)) {
                  current[segment] = nextIsIndex ? [] : {};
                }
                current = current[segment];
              } else {
                return;
              }
            } else {
              if (
                !Object.prototype.hasOwnProperty.call(current, targetIndex) ||
                current[targetIndex] === null ||
                typeof current[targetIndex] !== "object"
              ) {
                current[targetIndex] = nextIsIndex ? [] : {};
              }
              current = current[targetIndex];
            }
          } else {
            if (
              !Object.prototype.hasOwnProperty.call(current, segment) ||
              current[segment] === null ||
              typeof current[segment] !== "object"
            ) {
              current[segment] = nextIsIndex ? [] : {};
            }
            current = current[segment];
          }
        }
      }

      // Gestiona la edición manual de un campo extraído.
      function handleEditField(entry, key, label, currentValue) {
        if (!entry || !key) {
          return;
        }
        const fieldLabel = label || key || "Campo";
        let defaultValue = "";
        if (typeof currentValue === "string") {
          defaultValue = currentValue;
        } else if (
          typeof currentValue === "number" ||
          typeof currentValue === "boolean"
        ) {
          defaultValue = String(currentValue);
        } else if (currentValue && typeof currentValue === "object") {
          try {
            defaultValue = JSON.stringify(currentValue);
          } catch (error) {
            defaultValue = String(currentValue);
          }
        }
        const nextValue = window.prompt(`Editar valor de ${fieldLabel}`, defaultValue);
        if (nextValue === null) {
          return;
        }
        setValueForFlatKey(entry, key, nextValue);
        const normalizedKey = normalizeHighlightKey(key);
        if (!entry.editedFields || typeof entry.editedFields !== "object") {
          entry.editedFields = Object.create(null);
        }
        if (normalizedKey) {
          entry.editedFields[normalizedKey] = true;
          if (state.highlightVisibility && state.highlightVisibility[normalizedKey] === false) {
            delete state.highlightVisibility[normalizedKey];
          }
          if (state.highlightFocusKey === normalizedKey) {
            setHighlightFocusKey(null);
          }
          clearMissingHighlight(normalizedKey);
        }
        delete entry.previewHighlights;
        renderResult(state.currentIndex, { preserveHighlightVisibility: true });
      }

      // Sincroniza el estado visual de los botones que alternan grupos.
      function updateGroupToggleButton(button, active, title) {
        if (!button) {
          return;
        }
        button.classList.toggle("is-active", active);
        button.setAttribute("aria-pressed", active ? "true" : "false");
        button.textContent = active ? "Ocultar" : "Ver";
        const action = active ? "Ocultar" : "Ver";
        const target = title ? ` resaltados de ${title}` : " resaltados";
        button.setAttribute("aria-label", `${action}${target}`.trim());
        button.dataset.state = active ? "visible" : "oculto";
      }

      // Recalcula y aplica los resaltados de la vista previa actual.
      function refreshPreviewHighlights() {
        if (!state.results.length) {
          updateHighlightIndicators();
          return;
        }
        const entry = state.results[state.currentIndex];
        if (!entry) {
          updateHighlightIndicators();
          return;
        }
        const previewText = typeof entry.previewText === "string" ? entry.previewText : "";
        const origin = entry.textOrigin || "";
        const mode = resolveActivePreviewMode(entry);
        if (isPreviewDocked) {
          if (mode === "text") {
            if (previewText && previewText.trim()) {
              showPlainTextPreview(previewText, origin);
            } else {
              setDockedPreviewMessage("No hay contenido disponible.");
            }
          } else if (mode === "file") {
            renderCurrentPreview(entry);
          } else {
            setDockedPreviewMessage("No hay contenido disponible.");
          }
          updateHighlightIndicators();
          return;
        }
        if (!previewModal.hidden) {
          if (mode === "file") {
            showFilePreview(entry.file, entry.category, { entry });
          } else if (mode === "text") {
            showPlainTextPreview(previewText, origin);
          }
        }
        updateHighlightIndicators();
      }

      // Inserta HTML con resaltados dentro de un contenedor destino.
      function applyPreviewHighlights(target, text, highlights) {
        if (!target) {
          return;
        }
        const source = typeof text === "string" ? text : "";
        const matches = buildHighlightMatches(source, highlights);
        if (!matches.length) {
          target.textContent = source;
          return;
        }
        const fragments = [];
        let cursor = 0;
        matches.forEach((match) => {
          if (match.start > cursor) {
            fragments.push(escapeHtml(source.slice(cursor, match.start)));
          }
          const label = match.field || "(valor)";
          const attrLabel = escapeAttribute(label);
          const highlighted = escapeHtml(source.slice(match.start, match.end));
          fragments.push(
            `<span class="preview-highlight" data-field="${attrLabel}">${highlighted}</span>`
          );
          cursor = match.end;
        });
        if (cursor < source.length) {
          fragments.push(escapeHtml(source.slice(cursor)));
        }
        target.innerHTML = fragments.join("");
      }

      // Obtiene los resaltados precomputados para una entrada concreta.
      function getEntryHighlights(entry, precomputedFlat) {
        if (!entry) {
          return [];
        }
        if (Array.isArray(entry.previewHighlights)) {
          return entry.previewHighlights;
        }
        const flatData =
          precomputedFlat && typeof precomputedFlat === "object"
            ? precomputedFlat
            : flattenData(entry.data || {});
        let highlights = computePreviewHighlights(flatData);
        if (entry.editedFields && typeof entry.editedFields === "object") {
          const editedKeys = entry.editedFields;
          highlights = highlights.filter(({ field }) => {
            const key = normalizeHighlightKey(field);
            return !key || !editedKeys[key];
          });
        }
        entry.previewHighlights = highlights;
        return highlights;
      }

      // Normaliza la estructura del payload devuelto por la API.
      function normalizeExtractionResponse(payload, fallbackText = "") {
        const response =
          payload && typeof payload === "object" && !Array.isArray(payload) ? payload : {};
        const hasStructuredFields =
          response.fields &&
          typeof response.fields === "object" &&
          !Array.isArray(response.fields) &&
          (Object.prototype.hasOwnProperty.call(response, "raw_text") ||
            Object.prototype.hasOwnProperty.call(response, "text_origin"));
        const fieldsCandidate = hasStructuredFields ? response.fields : response;
        const fallback = typeof fallbackText === "string" ? fallbackText : "";
        const rawText =
          typeof response.raw_text === "string" && response.raw_text.trim()
            ? response.raw_text
            : fallback;
        const normalizedOrigin =
          typeof response.text_origin === "string"
            ? response.text_origin.trim().toLowerCase()
            : "";
        const origin = normalizedOrigin ? normalizedOrigin : rawText ? "input" : "";
        return {
          fields: fieldsCandidate,
          rawText,
          textOrigin: origin,
        };
      }

      // Produce identificadores consistentes para claves de campos.
      function normalizeFieldIdentifier(key) {
        if (key === null || key === undefined) {
          return "";
        }
        return String(key)
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z0-9]/gi, "")
          .toLowerCase();
      }

      // Selecciona el valor más adecuado para alimentar la predicción.
      function pickPredictionValue(flatData, candidates, fallbackKey) {
        if (!flatData || typeof flatData !== "object") {
          return null;
        }
        const keys = Array.isArray(candidates) ? candidates : [];
        for (let index = 0; index < keys.length; index += 1) {
          const key = keys[index];
          if (!key) {
            continue;
          }
          if (Object.prototype.hasOwnProperty.call(flatData, key)) {
            const value = flatData[key];
            if (value !== null && value !== undefined && value !== "") {
              return value;
            }
          }
        }
        if (fallbackKey) {
          const normalizedTarget = normalizeFieldIdentifier(fallbackKey);
          if (normalizedTarget) {
            const entries = Object.entries(flatData);
            for (let index = 0; index < entries.length; index += 1) {
              const [candidateKey, candidateValue] = entries[index];
              if (
                candidateValue === null ||
                candidateValue === undefined ||
                candidateValue === ""
              ) {
                continue;
              }
              const normalizedCandidate = normalizeFieldIdentifier(candidateKey);
              if (
                normalizedCandidate === normalizedTarget ||
                normalizedCandidate.endsWith(normalizedTarget)
              ) {
                return candidateValue;
              }
            }
          }
        }
        return null;
      }

      // Limpia y estandariza la categoría predicha.
      function normalizePredictionCategory(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const text = String(value).trim();
        if (!text) {
          return null;
        }
        return text.toUpperCase();
      }

      // Convierte valores numéricos de la predicción en floats.
      function parseNumericValue(value) {
        if (value === null || value === undefined) {
          return null;
        }
        if (typeof value === "number") {
          return Number.isFinite(value) ? value : null;
        }
        if (typeof value === "string") {
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }
          const sanitized = trimmed.replace(/\s+/g, "").replace(/[^0-9,.-]/g, "");
          if (!sanitized) {
            return null;
          }
          const lastComma = sanitized.lastIndexOf(",");
          const lastDot = sanitized.lastIndexOf(".");
          let normalized = sanitized;
          if (lastComma > lastDot) {
            normalized = normalized.replace(/\./g, "");
            normalized = normalized.replace(/,/g, ".");
          } else {
            normalized = normalized.replace(/,/g, "");
          }
          const parsed = Number(normalized);
          if (!Number.isFinite(parsed)) {
            return null;
          }
          return parsed;
        }
        return null;
      }

      // Redondea y valida valores numéricos como enteros.
      function parseIntegerValue(value) {
        const numeric = parseNumericValue(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }
        return Math.round(numeric);
      }

      // Construye el diccionario de características para el modelo clásico.
      function collectPredictionFeatures(entry, precomputedFlat) {
        if (!entry || typeof entry !== "object") {
          return {
            ready: false,
            missing: [...PREDICTION_REQUIRED_FIELDS],
            payload: {},
            signature: null,
            flat: {},
          };
        }
        const baseData = entry.data && typeof entry.data === "object" ? entry.data : {};
        const flat =
          precomputedFlat && typeof precomputedFlat === "object"
            ? precomputedFlat
            : flattenData(baseData);
        const prepared = {};
        const missing = [];
        const marca = normalizePredictionCategory(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.marca, "marca")
        );
        if (marca) {
          prepared.marca = marca;
        } else {
          missing.push("marca");
        }
        const tipo = normalizePredictionCategory(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.tipo, "tipo")
        );
        if (tipo) {
          prepared.tipo = tipo;
        } else {
          missing.push("tipo");
        }
        const clase = normalizePredictionCategory(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.clase, "clase")
        );
        if (clase) {
          prepared.clase = clase;
        } else {
          missing.push("clase");
        }
        const capacidad = parseIntegerValue(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.capacidad, "capacidad")
        );
        if (Number.isFinite(capacidad)) {
          prepared.capacidad = capacidad;
        } else {
          missing.push("capacidad");
        }
        const combustible = normalizePredictionCategory(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.combustible, "combustible")
        );
        if (combustible) {
          prepared.combustible = combustible;
        } else {
          missing.push("combustible");
        }
        const ruedas = parseIntegerValue(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.ruedas, "ruedas")
        );
        if (Number.isFinite(ruedas)) {
          prepared.ruedas = ruedas;
        } else {
          missing.push("ruedas");
        }
        const total = parseNumericValue(
          pickPredictionValue(flat, PREDICTION_FIELD_CANDIDATES.total, "total")
        );
        if (Number.isFinite(total)) {
          prepared.total = Number(total.toFixed(2));
        } else {
          missing.push("total");
        }
        const ready = missing.length === 0;
        return {
          ready,
          missing,
          payload: prepared,
          signature: ready ? JSON.stringify(prepared) : null,
          flat,
        };
      }

      // Formatea una probabilidad en porcentaje legible.
      function formatPredictionPercentage(value) {
        if (!Number.isFinite(value)) {
          return "0%";
        }
        const percentage = value * 100;
        if (percentage >= 99.95) {
          return "100%";
        }
        if (percentage <= 0.05) {
          return "0%";
        }
        return `${percentage.toFixed(1)}%`;
      }

      // Marca que las probabilidades ya no son válidas y deben recalcularse.
      function markPredictionDirty(entry) {
        if (!entry || typeof entry !== "object") {
          return;
        }
        if (entry.prediction && typeof entry.prediction === "object") {
          entry.prediction.needsRefresh = true;
        }
      }

      // Devuelve una etiqueta descriptiva del origen del texto procesado.
      function getTextOriginDescription(origin) {
        switch (origin) {
          case "ocr":
            return "Contenido obtenido mediante OCR.";
          case "file":
            return "Texto extraído directamente del archivo.";
          case "input":
            return "Texto proporcionado manualmente.";
          default:
            return "";
        }
      }

      // Determina qué modo de vista previa debe mostrarse.
      function resolveActivePreviewMode(entry) {
        if (!entry) {
          return null;
        }
        const hasFile = isFilePreviewAvailable(entry);
        const hasText =
          typeof entry.previewText === "string" && entry.previewText.trim().length > 0;
        if (state.previewMode === "file") {
          if (hasFile) {
            return "file";
          }
          return hasText ? "text" : null;
        }
        if (state.previewMode === "text") {
          if (hasText) {
            return "text";
          }
          return hasFile ? "file" : null;
        }
        if (hasText) {
          return "text";
        }
        if (hasFile) {
          return "file";
        }
        return null;
      }

      // Actualiza los botones que alternan el modo de vista previa.
      function updatePreviewModeControls(entry) {
        if (!previewModeToggle) {
          return;
        }
        const hasEntry = Boolean(entry);
        const hasFile = isFilePreviewAvailable(entry);
        const hasText =
          hasEntry &&
          typeof entry.previewText === "string" &&
          entry.previewText.trim().length > 0;
        if (!hasEntry) {
          state.previewMode = "text";
        } else if (state.previewMode === "file" && !hasFile) {
          state.previewMode = "text";
        } else if (state.previewMode !== "file" && !hasText && hasFile) {
          state.previewMode = "file";
        }
        if (previewModeTextButton) {
          previewModeTextButton.disabled = !hasEntry || !hasText;
        }
        if (previewModeFileButton) {
          previewModeFileButton.disabled = !hasFile;
        }
        if (previewModeButtons.length) {
          previewModeButtons.forEach((button) => {
            const mode = button.dataset.mode || "";
            const isActive = state.previewMode === mode;
            button.classList.toggle("is-active", isActive);
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        }
        previewModeToggle.setAttribute("aria-disabled", hasEntry ? "false" : "true");
      }

      // Carga la vista previa acoplada correspondiente a un archivo.
      function renderDockedFilePreview(file, category, entry) {
        if (!dockedPreviewContent || !file) {
          setDockedPreviewMessage("No hay vista previa disponible.");
          return;
        }
        clearMissingHighlightNotice(dockedPreviewContent);
        const label =
          (entry && typeof entry.source === "string" && entry.source.trim()) ||
          (typeof file.name === "string" && file.name.trim()) ||
          "";
        if (dockedPreviewHint) {
          if (label) {
            dockedPreviewHint.hidden = false;
            dockedPreviewHint.textContent = `Vista del archivo original (${label}).`;
          } else {
            dockedPreviewHint.hidden = false;
            dockedPreviewHint.textContent = "Vista del archivo original.";
          }
        }
        clearDockedPreviewUrl();
        const normalizedCategory = String(category || "").toLowerCase();
        if (normalizedCategory === "image") {
          const url = URL.createObjectURL(file);
          state.dockedPreviewUrl = url;
          const img = document.createElement("img");
          img.src = url;
          img.alt = "Vista previa del archivo original";
          dockedPreviewContent.replaceChildren(img);
          return;
        }
        if (normalizedCategory === "pdf") {
          const url = URL.createObjectURL(file);
          state.dockedPreviewUrl = url;
          const iframe = document.createElement("iframe");
          iframe.src = url;
          iframe.title = "Vista previa del archivo original";
          dockedPreviewContent.replaceChildren(iframe);
          return;
        }
        const placeholder = document.createElement("p");
        placeholder.className = "preview-placeholder";
        placeholder.textContent = "Cargando vista previa del archivo...";
        dockedPreviewContent.replaceChildren(placeholder);
        const reader = new FileReader();
        const token = ++dockedFileReadToken;
        reader.onload = () => {
          if (token !== dockedFileReadToken) {
            return;
          }
          const pre = document.createElement("pre");
          pre.textContent = String(reader.result || "").slice(0, 20000);
          dockedPreviewContent.replaceChildren(pre);
        };
        reader.onerror = () => {
          if (token !== dockedFileReadToken) {
            return;
          }
          setDockedPreviewMessage("No se pudo cargar la vista del archivo.");
        };
        reader.readAsText(file, "utf-8");
      }

      // Presenta un archivo en el panel de vista previa seleccionado.
      function showFilePreview(file, category, options = {}) {
        if (!file || !category) {
          if (isPreviewDocked) {
            setDockedPreviewMessage("No hay vista previa disponible.");
          } else {
            previewModalContent.innerHTML = "";
            const message = document.createElement("p");
            message.style.padding = "1.25rem";
            message.textContent = "No hay vista previa disponible.";
            previewModalContent.appendChild(message);
            if (previewModal.hidden) {
              openPreviewModal();
            }
          }
          return;
        }
        if (isPreviewDocked) {
          renderDockedFilePreview(file, category, options.entry || null);
          return;
        }
        renderModalPreview(file, category);
        if (previewModal.hidden) {
          openPreviewModal();
        }
      }

      // Renderiza el contenido de vista previa para la entrada activa.
      function renderCurrentPreview(entry) {
        if (!isPreviewDocked) {
          return;
        }
        const targetEntry = entry || state.results[state.currentIndex];
        if (!targetEntry) {
          resetDockedPreview();
          return;
        }
        const mode = resolveActivePreviewMode(targetEntry);
        if (mode === "file") {
          showFilePreview(targetEntry.file, targetEntry.category, { entry: targetEntry });
          return;
        }
        if (mode === "text") {
          showPlainTextPreview(targetEntry.previewText, targetEntry.textOrigin || "");
          return;
        }
        setDockedPreviewMessage("No hay contenido disponible.");
      }

      // Ajusta el estado del botón que abre la vista previa detallada.
      function updateViewContentButton(entry) {
        if (!viewContentButton) {
          return;
        }
        if (!entry) {
          viewContentButton.disabled = true;
          viewContentButton.setAttribute("aria-label", "Ver contenido");
          viewContentButton.removeAttribute("title");
          return;
        }
        const mode = resolveActivePreviewMode(entry);
        viewContentButton.disabled = !mode;
        if (!mode) {
          viewContentButton.setAttribute("aria-label", "Ver contenido");
          viewContentButton.removeAttribute("title");
          return;
        }
        if (mode === "file") {
          viewContentButton.setAttribute("aria-label", "Ver archivo original");
          const fileLabel =
            (entry.file && typeof entry.file.name === "string" && entry.file.name) ||
            (typeof entry.source === "string" && entry.source) ||
            "";
          if (fileLabel) {
            viewContentButton.setAttribute("title", fileLabel);
          } else {
            viewContentButton.removeAttribute("title");
          }
          return;
        }
        const description = getTextOriginDescription(entry.textOrigin || "");
        if (description) {
          viewContentButton.setAttribute(
            "aria-label",
            `Ver contenido. ${description}`
          );
          viewContentButton.setAttribute("title", description);
        } else {
          viewContentButton.setAttribute("aria-label", "Ver contenido");
          viewContentButton.removeAttribute("title");
        }
      }

      // Abre la vista previa adecuada según el modo seleccionado.
      function openActivePreview() {
        const entry = state.results[state.currentIndex];
        const mode = resolveActivePreviewMode(entry);
        if (!entry || !mode) {
          return;
        }
        state.currentHighlights = getEntryHighlights(entry);
        if (mode === "file") {
          showFilePreview(entry.file, entry.category, { entry });
        } else {
          showPlainTextPreview(entry.previewText, entry.textOrigin || "");
        }
      }

      // Muestra el texto bruto asociado a la extracción.
      function showPlainTextPreview(text, origin) {
        if (state.modalPreviewUrl) {
          URL.revokeObjectURL(state.modalPreviewUrl);
          state.modalPreviewUrl = null;
        }
        clearDockedPreviewUrl();
        const normalized = typeof text === "string" ? text : "";
        const hint = getTextOriginDescription(origin);
        const visibleHighlights = getVisibleHighlights();
        if (isPreviewDocked && dockedPreviewContent) {
          if (!normalized.trim()) {
            setDockedPreviewMessage("No hay contenido disponible.");
            return;
          }
          if (dockedPreviewHint) {
            if (hint) {
              dockedPreviewHint.hidden = false;
              dockedPreviewHint.textContent = hint;
            } else {
              dockedPreviewHint.hidden = true;
              dockedPreviewHint.textContent = "";
            }
          }
          const pre = document.createElement("pre");
          applyPreviewHighlights(pre, normalized, visibleHighlights);
          dockedPreviewContent.replaceChildren(pre);
          updateMissingHighlightNotice(dockedPreviewContent, visibleHighlights, {
            mode: "text",
          });
          return;
        }
        previewModalContent.innerHTML = "";
        if (!normalized.trim()) {
          const message = document.createElement("p");
          message.style.padding = "1.25rem";
          message.textContent = "No hay contenido disponible.";
          previewModalContent.appendChild(message);
          if (previewModal.hidden) {
            openPreviewModal();
          }
          return;
        }
        if (hint) {
          const hintElement = document.createElement("p");
          hintElement.className = "preview-hint";
          hintElement.textContent = hint;
          previewModalContent.appendChild(hintElement);
        }
        const pre = document.createElement("pre");
        applyPreviewHighlights(pre, normalized, visibleHighlights);
        previewModalContent.appendChild(pre);
        updateMissingHighlightNotice(previewModalContent, visibleHighlights, {
          mode: "text",
        });
        if (previewModal.hidden) {
          openPreviewModal();
        }
      }

      // Define mensajes informativos o de error en la sección de predicción.
      function setPredictionMessage(message, options = {}) {
        if (!predictionContent) {
          return;
        }
        const paragraph = document.createElement("p");
        paragraph.className = options.className || "prediction-placeholder";
        paragraph.textContent = message;
        predictionContent.replaceChildren(paragraph);
      }

      // Actualiza el mensaje que indica el estado del reentrenamiento.
      function updateRetrainStatus(message, tone) {
        if (!retrainRandomForestStatus) {
          return;
        }
        const normalizedMessage = message ? String(message).trim() : "";
        retrainRandomForestStatus.textContent = normalizedMessage;
        if (!normalizedMessage) {
          retrainRandomForestStatus.hidden = true;
          retrainRandomForestStatus.classList.remove("is-error", "is-success");
          return;
        }
        retrainRandomForestStatus.hidden = false;
        retrainRandomForestStatus.classList.remove("is-error", "is-success");
        if (tone === "error") {
          retrainRandomForestStatus.classList.add("is-error");
        } else if (tone === "success") {
          retrainRandomForestStatus.classList.add("is-success");
        }
      }

      // Indica que las predicciones previas deben regenerarse.
      function markPredictionsAsStale() {
        let marked = false;
        state.results.forEach((entry) => {
          if (
            entry &&
            typeof entry === "object" &&
            entry.prediction &&
            typeof entry.prediction === "object" &&
            entry.prediction.status === "success"
          ) {
            entry.prediction.needsRefresh = true;
            marked = true;
          }
        });
        if (marked && state.currentIndex >= 0) {
          const currentEntry = state.results[state.currentIndex];
          if (currentEntry) {
            const features = collectPredictionFeatures(currentEntry);
            renderPredictionCard(currentEntry, features);
          }
        }
      }

      // Genera el bloque visual que muestra probabilidades y clase.
      function renderPredictionResult(predictionState) {
        if (!predictionContent) {
          return;
        }
        const wrapper = document.createElement("div");
        wrapper.className = "prediction-result";
        const label = document.createElement("p");
        label.className = "prediction-result__label";
        const category =
          predictionState && typeof predictionState.category === "string"
            ? predictionState.category
            : "";
        label.textContent = category
          ? `Categoría predicha: ${category}`
          : "Categoría predicha:";
        wrapper.appendChild(label);
        const probabilitiesSource = Array.isArray(predictionState?.probabilities)
          ? predictionState.probabilities.slice()
          : [];
        if (probabilitiesSource.length) {
          probabilitiesSource.sort((a, b) => {
            const valueA = Number(a?.probabilidad ?? a?.probability ?? 0);
            const valueB = Number(b?.probabilidad ?? b?.probability ?? 0);
            return valueB - valueA;
          });
          const list = document.createElement("ul");
          list.className = "prediction-probabilities";
          probabilitiesSource.forEach((item) => {
            const listItem = document.createElement("li");
            const name = document.createElement("span");
            name.className = "prediction-probability__name";
            const labelText =
              typeof item?.clase === "string"
                ? item.clase
                : typeof item?.category === "string"
                ? item.category
                : typeof item?.label === "string"
                ? item.label
                : "";
            name.textContent = labelText || "—";
            listItem.appendChild(name);
            const valueContainer = document.createElement("span");
            valueContainer.className = "prediction-probability__value";
            const meter = document.createElement("span");
            meter.className = "prediction-probability__meter";
            const bar = document.createElement("span");
            bar.className = "prediction-probability__meter-bar";
            const probabilityValue = Number(item?.probabilidad ?? item?.probability ?? 0);
            const width = Math.max(0, Math.min(100, Math.round(probabilityValue * 100)));
            bar.style.width = `${width}%`;
            meter.appendChild(bar);
            const percent = document.createElement("strong");
            percent.textContent = formatPredictionPercentage(probabilityValue);
            valueContainer.appendChild(meter);
            valueContainer.appendChild(percent);
            listItem.appendChild(valueContainer);
            list.appendChild(listItem);
          });
          wrapper.appendChild(list);
        }
        predictionContent.replaceChildren(wrapper);
      }

      // Rellena la tarjeta lateral con los datos de predicción.
      function renderPredictionCard(entry, features) {
        if (!predictionCard) {
          return;
        }
        if (!entry) {
          predictionCard.hidden = true;
          if (predictionSubtitle) {
            predictionSubtitle.textContent = "";
          }
          if (predictionContent) {
            predictionContent.innerHTML = "";
          }
          if (retryPredictionButton) {
            retryPredictionButton.disabled = true;
          }
          return;
        }
        predictionCard.hidden = false;
        const state =
          entry.prediction && typeof entry.prediction === "object" ? entry.prediction : null;
        const status = state ? state.status : null;
        const needsRefresh = Boolean(state && state.needsRefresh);
        const ready = Boolean(features && features.ready);
        const missingFields =
          features && Array.isArray(features.missing)
            ? features.missing
            : PREDICTION_REQUIRED_FIELDS;
        let subtitle = "";
        let buttonLabel = state ? "Reintentar" : "Calcular";
        let buttonDisabled = false;

        if (!ready) {
          if (state && state.status === "success") {
            renderPredictionResult(state);
            const note = document.createElement("p");
            note.className = "prediction-note";
            note.textContent = missingFields.length
              ? `Proporciona los campos faltantes (${missingFields.join(", ")}) para recalcular la predicción.`
              : "Proporciona los campos requeridos para recalcular la predicción.";
            predictionContent.appendChild(note);
            subtitle = "Faltan datos para recalcular la predicción.";
            buttonDisabled = true;
            buttonLabel = "Recalcular";
          } else {
            const message = missingFields.length
              ? `Faltan los campos: ${missingFields.join(", ")}.`
              : "Proporciona los campos requeridos para ejecutar la predicción.";
            setPredictionMessage(message);
            subtitle = "Completa los campos requeridos para ejecutar la predicción.";
            buttonDisabled = true;
            buttonLabel = state ? "Reintentar" : "Calcular";
          }
        } else if (status === "loading") {
          setPredictionMessage("Calculando predicción...");
          subtitle = "Calculando predicción...";
          buttonDisabled = true;
        } else if (status === "error") {
          const message =
            typeof state.message === "string" && state.message.trim()
              ? state.message
              : "No se pudo obtener la predicción.";
          setPredictionMessage(message, { className: "prediction-error" });
          subtitle = "Ocurrió un error al obtener la predicción.";
          buttonDisabled = false;
          buttonLabel = "Reintentar";
        } else if (status === "success") {
          renderPredictionResult(state);
          if (needsRefresh) {
            const note = document.createElement("p");
            note.className = "prediction-note";
            note.textContent =
              "Los datos cambiaron. Ejecuta nuevamente la predicción para actualizar el resultado.";
            predictionContent.appendChild(note);
            subtitle = "Los datos cambiaron. Recalcula la predicción.";
            buttonDisabled = false;
            buttonLabel = "Recalcular";
          } else {
            const timestamp =
              state.obtainedAt && Number.isFinite(state.obtainedAt)
                ? new Date(state.obtainedAt).toLocaleString()
                : "";
            subtitle = timestamp ? `Última actualización: ${timestamp}.` : "Predicción lista.";
            buttonDisabled = false;
            buttonLabel = "Reintentar";
          }
        } else {
          setPredictionMessage("Ejecuta la predicción para conocer la categoría estimada.");
          subtitle = "Predicción lista para ejecutarse.";
          buttonDisabled = false;
          buttonLabel = "Calcular";
        }

        if (predictionSubtitle) {
          predictionSubtitle.textContent = subtitle;
        }
        if (retryPredictionButton) {
          retryPredictionButton.disabled = buttonDisabled;
          retryPredictionButton.textContent = buttonLabel;
        }
      }

      // Decide si se debe ejecutar la predicción automáticamente.
      function shouldAutoRunPrediction(entry, features) {
        if (!entry || !features || !features.ready) {
          return false;
        }
        const state =
          entry.prediction && typeof entry.prediction === "object" ? entry.prediction : null;
        if (!state) {
          return true;
        }
        if (state.status === "loading") {
          return false;
        }
        if (state.needsRefresh) {
          return false;
        }
        if (state.status === "success") {
          return state.inputSignature !== features.signature;
        }
        return false;
      }

      async function triggerPrediction(entry, features) {
        if (!entry || !features || !features.ready) {
          return;
        }
        const payload = features.payload || {};
        const signature = features.signature || JSON.stringify(payload);
        const requestId = (entry.predictionRequestId || 0) + 1;
        entry.predictionRequestId = requestId;
        entry.prediction = {
          status: "loading",
          needsRefresh: false,
          inputSignature: signature,
          features: payload,
        };
        if (state.results[state.currentIndex] === entry) {
          renderPredictionCard(entry, features);
        }
        try {
          const response = await fetch(PREDICTION_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let detail = "No se pudo obtener la predicción.";
            try {
              const errorBody = await response.json();
              if (errorBody && typeof errorBody.detail === "string") {
                detail = errorBody.detail;
              }
            } catch (error) {
              // Ignorado a propósito
            }
            throw new Error(detail);
          }
          const data = await response.json();
          if (entry.predictionRequestId !== requestId) {
            return;
          }
          const probabilitiesSource = Array.isArray(data?.probabilidades)
            ? data.probabilidades
            : [];
          const probabilities = probabilitiesSource.map((item) => ({
            clase:
              typeof item?.clase === "string"
                ? item.clase
                : typeof item?.category === "string"
                ? item.category
                : typeof item?.label === "string"
                ? item.label
                : "",
            probabilidad: Number(item?.probabilidad ?? item?.probability ?? 0),
          }));
          const categoryValue =
            typeof data?.categoria_predicha === "string"
              ? data.categoria_predicha
              : typeof data?.predicted_class === "string"
              ? data.predicted_class
              : "";
          const valoresEntrada =
            data?.valores_entrada && typeof data.valores_entrada === "object"
              ? data.valores_entrada
              : payload;
          entry.prediction = {
            status: "success",
            category: categoryValue || "",
            probabilities,
            features: valoresEntrada,
            inputSignature: signature,
            obtainedAt: Date.now(),
            needsRefresh: false,
          };
        } catch (error) {
          if (entry.predictionRequestId !== requestId) {
            return;
          }
          const message =
            error && typeof error.message === "string" && error.message.trim()
              ? error.message
              : "No se pudo obtener la predicción.";
          entry.prediction = {
            status: "error",
            message,
            features: payload,
            inputSignature: signature,
            needsRefresh: false,
          };
        }
        if (state.results[state.currentIndex] === entry) {
          const refreshed = collectPredictionFeatures(entry, features.flat);
          renderPredictionCard(entry, refreshed);
        }
      }


      // Construye los datos descargables para resultados de predicción.
      function getPredictionDownload(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const state =
          entry.prediction && typeof entry.prediction === "object" ? entry.prediction : null;
        if (!state) {
          return null;
        }
        const download = {
          estado: state.status || "desconocido",
        };
        if (state.features) {
          download.valores_entrada = state.features;
        }
        if (state.needsRefresh) {
          download.necesita_actualizacion = true;
        }
        if (state.status === "success") {
          download.categoria_predicha = state.category || "";
          download.probabilidades = Array.isArray(state.probabilities)
            ? state.probabilities.map((item) => ({
                clase:
                  typeof item?.clase === "string"
                    ? item.clase
                    : typeof item?.category === "string"
                    ? item.category
                    : typeof item?.label === "string"
                    ? item.label
                    : "",
                probabilidad: Number(item?.probabilidad ?? item?.probability ?? 0),
              }))
            : [];
          if (state.obtainedAt && Number.isFinite(state.obtainedAt)) {
            download.calculada_en = new Date(state.obtainedAt).toISOString();
          }
        } else if (state.status === "error" && state.message) {
          download.mensaje = state.message;
        }
        return download;
      }




      // Dibuja la información del resultado seleccionado.
      function renderResult(index, options = {}) {
        if (isPreviewDocked) {
          resetDockedPreview();
        }
        const preserveHighlightVisibility = Boolean(
          options && options.preserveHighlightVisibility
        );
        const visibilitySnapshot =
          preserveHighlightVisibility && state.highlightVisibility
            ? Object.assign(Object.create(null), state.highlightVisibility)
            : null;
        state.highlightFocusKey = null;
        state.highlightIndex = Object.create(null);
        if (state.results.length === 0) {
          state.currentHighlights = [];
          state.highlightVisibility = visibilitySnapshot || {};
          resultsContainer.classList.add("empty");
          resultsContainer.innerHTML =
            "Aún no hay resultados. Procesa un documento para comenzar.";
          resultsSummary.textContent = "Procesa un documento para ver los campos extraídos.";
          resultsNavigation.hidden = true;
          resultMeta.hidden = true;
          updatePreviewModeControls(null);
          updateViewContentButton(null);
          downloadJson.disabled = true;
          downloadCsv.disabled = true;
          renderPredictionCard(null, null);
          updateHighlightIndicators();
          return;
        }

        const safeIndex = Math.min(
          Math.max(typeof index === "number" ? index : 0, 0),
          state.results.length - 1
        );
        state.currentIndex = safeIndex;
        const entry = state.results[safeIndex];
        if (!entry) {
          state.currentHighlights = [];
          state.highlightVisibility = visibilitySnapshot || {};
          state.missingHighlight = null;
          updatePreviewModeControls(null);
          updateViewContentButton(null);
          renderPredictionCard(null, null);
          updateHighlightIndicators();
          return;
        }
        updatePreviewModeControls(entry);
        updateViewContentButton(entry);
        const uploadedAt = entry.uploadedAt || entry.timestamp;
        resultsContainer.classList.remove("empty");
        resultsContainer.innerHTML = "";
        resultsSummary.textContent = `Última actualización: ${new Date(
          uploadedAt
        ).toLocaleString()}`;

        const flat = flattenData(entry.data);
        const predictionFeatures = collectPredictionFeatures(entry, flat);
        renderPredictionCard(entry, predictionFeatures);
        if (shouldAutoRunPrediction(entry, predictionFeatures)) {
          triggerPrediction(entry, predictionFeatures);
        }
        const highlights = getEntryHighlights(entry, flat);
        state.currentHighlights = Array.isArray(highlights) ? highlights : [];
        state.missingHighlight = null;
        state.highlightIndex = state.currentHighlights.reduce((acc, highlight) => {
          const key = normalizeHighlightKey(highlight.field);
          if (!key) {
            return acc;
          }
          if (!acc[key]) {
            acc[key] = [];
          }
          acc[key].push(highlight);
          return acc;
        }, Object.create(null));
        state.highlightVisibility = visibilitySnapshot || {};
        const flatKeys = Object.keys(flat);
        const usedKeys = new Set();

        const resolveFieldKey = (target) => {
          if (flatKeys.includes(target)) {
            return target;
          }
          const normalized = target.toLowerCase();
          let candidate = flatKeys.find((key) => key.toLowerCase() === normalized);
          if (candidate) {
            return candidate;
          }
          candidate = flatKeys.find((key) => key.toLowerCase().endsWith(`.${normalized}`));
          if (candidate) {
            return candidate;
          }
          return target;
        };

        const createFieldElement = (key, labelOverride) => {
          const field = document.createElement("div");
          field.className = "result-field";
          field.dataset.fieldKey = key;
          field.setAttribute("role", "button");
          field.tabIndex = 0;
          const labelText = labelOverride || key || "(valor)";
          field.setAttribute("aria-label", `Editar ${labelText}`);
          field.title = `Editar ${labelText}`;
          const header = document.createElement("div");
          header.className = "result-field__header";
          const label = document.createElement("span");
          label.className = "result-field__label";
          label.textContent = labelText;
          header.appendChild(label);
          field.appendChild(header);
          const valueElement = document.createElement("div");
          valueElement.className = "value";
          const hasValue = Object.prototype.hasOwnProperty.call(flat, key);
          const value = hasValue ? flat[key] : undefined;
          if (
            !hasValue ||
            value === null ||
            value === undefined ||
            value === "" ||
            (Array.isArray(value) && value.length === 0)
          ) {
            valueElement.classList.add("missing");
            valueElement.textContent = "Sin valor";
          } else if (typeof value === "object") {
            valueElement.textContent = JSON.stringify(value);
          } else {
            valueElement.textContent = String(value);
          }
          field.appendChild(valueElement);
          const highlightKey = normalizeHighlightKey(key);
          const highlightEntries =
            highlightKey && state.highlightIndex ? state.highlightIndex[highlightKey] : null;
          if (highlightEntries && highlightEntries.length) {
            field.dataset.highlightKey = highlightKey;
            const isSuppressed = () =>
              !!(
                state.highlightVisibility &&
                Object.prototype.hasOwnProperty.call(state.highlightVisibility, highlightKey) &&
                state.highlightVisibility[highlightKey] === false
              );
            if (isSuppressed()) {
              field.classList.add("result-field--muted");
            } else {
              field.classList.add("result-field--highlighted");
            }
            const activate = () => {
              if (isSuppressed()) {
                return;
              }
              const focusChanged = setHighlightFocusKey(highlightKey);
              const missingCleared = clearMissingHighlight();
              if (focusChanged || missingCleared) {
                refreshPreviewHighlights();
              }
            };
            const clear = () => {
              let shouldRefresh = false;
              if (state.highlightFocusKey === highlightKey) {
                shouldRefresh = setHighlightFocusKey(null) || shouldRefresh;
              }
              shouldRefresh = clearMissingHighlight(highlightKey) || shouldRefresh;
              if (shouldRefresh) {
                refreshPreviewHighlights();
              }
            };
            field.addEventListener("pointerenter", activate);
            field.addEventListener("pointerleave", clear);
            field.addEventListener("mouseenter", activate);
            field.addEventListener("mouseleave", clear);
            field.addEventListener("focus", activate);
            field.addEventListener("blur", clear);
          } else if (highlightKey) {
            const activateMissing = () => {
              const focusChanged = setHighlightFocusKey(highlightKey, { allowMissing: true });
              const missingChanged = setMissingHighlight(highlightKey, labelText);
              if (focusChanged || missingChanged) {
                refreshPreviewHighlights();
              }
            };
            const clearMissing = () => {
              let shouldRefresh = false;
              if (state.highlightFocusKey === highlightKey) {
                shouldRefresh = setHighlightFocusKey(null) || shouldRefresh;
              }
              shouldRefresh = clearMissingHighlight(highlightKey) || shouldRefresh;
              if (shouldRefresh) {
                refreshPreviewHighlights();
              }
            };
            field.addEventListener("pointerenter", activateMissing);
            field.addEventListener("pointerleave", clearMissing);
            field.addEventListener("mouseenter", activateMissing);
            field.addEventListener("mouseleave", clearMissing);
            field.addEventListener("focus", activateMissing);
            field.addEventListener("blur", clearMissing);
          }

          const triggerEdit = () => {
            const currentValue = Object.prototype.hasOwnProperty.call(flat, key)
              ? flat[key]
              : undefined;
            handleEditField(entry, key, labelText, currentValue);
          };

          field.addEventListener("click", (event) => {
            if (event.defaultPrevented) {
              return;
            }
            triggerEdit();
          });

          field.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              triggerEdit();
            }
          });

          usedKeys.add(key);
          return field;
        };

        const prioritizedGroups = [
          {
            title: "DETALLES GENERALES",
            fields: [
              "NUMERO_FACTURA",
              "NOMBRE_CLIENTE",
              "RUC",
              "CONCESIONARIA",
              "DIRECCION",
              "FECHA_DOCUMENTO",
              "AÑO",
              "PAIS_ORIGEN",
            ],
          },
          {
            title: "VEHICULO",
            fields: [
              "MARCA",
              "MODELO",
              "MODELO_HOMOLOGADO_ANT",
              "MODELO_REGISTRADO_SRI",
              "TIPO",
              "CLASE",
              "COLOR",
              "MOTOR",
              "RAMV_CPN",
              "VIN_CHASIS",
              "CILINDRAJE",
              "CAPACIDAD",
              "RUEDAS",
              "EJES",
              "TONELAJE",
              "COMBUSTIBLE",
            ],
          },
          {
            title: "FACTURA",
            fields: ["SUBTOTAL", "SUBSIDIO", "DESCUENTO", "IVA", "TOTAL"],
          },
        ];

        prioritizedGroups.forEach(({ title, fields }) => {
          if (!Array.isArray(fields) || !fields.length) {
            return;
          }
          const section = document.createElement("section");
          section.className = "results-section";
          const header = document.createElement("div");
          header.className = "results-section__header";
          const heading = document.createElement("h4");
          heading.className = "results-section__title";
          heading.textContent = title;
          header.appendChild(heading);
          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "results-section__toggle";
          header.appendChild(toggle);
          section.appendChild(header);
          const grid = document.createElement("div");
          grid.className = "results-section__grid";
          const resolvedGroupFields = [];
          fields.forEach((key) => {
            const resolvedKey = resolveFieldKey(key);
            if (usedKeys.has(resolvedKey)) {
              return;
            }
            resolvedGroupFields.push(resolvedKey);
            grid.appendChild(createFieldElement(resolvedKey, key));
          });
          if (!grid.children.length) {
            return;
          }
          section.appendChild(grid);
          const groupFields = resolvedGroupFields.slice();
          const normalizedGroupKeys = groupFields
            .map((fieldKey) => normalizeHighlightKey(fieldKey))
            .filter(Boolean);
          const allHidden =
            normalizedGroupKeys.length > 0 &&
            normalizedGroupKeys.every((fieldKey) => {
              if (!state.highlightVisibility) {
                return false;
              }
              return state.highlightVisibility[fieldKey] === false;
            });
          let isActive = !allHidden;
          updateGroupToggleButton(toggle, isActive, title);
          toggle.addEventListener("click", () => {
            isActive = !isActive;
            setGroupHighlightVisibility(groupFields, isActive);
            updateGroupToggleButton(toggle, isActive, title);
            if (!isActive) {
              setHighlightFocusKey(null);
            }
            refreshPreviewHighlights();
          });
          if (!preserveHighlightVisibility) {
            setGroupHighlightVisibility(groupFields, true);
            isActive = true;
            updateGroupToggleButton(toggle, isActive, title);
          }
          resultsContainer.appendChild(section);
        });

        flatKeys
          .filter((key) => !usedKeys.has(key))
          .sort((a, b) => a.localeCompare(b))
          .forEach((key) => {
            resultsContainer.appendChild(createFieldElement(key));
          });

        resultMeta.hidden = false;
        const metaParts = [
          `<div><span class="pill">${entry.source}</span></div>`,
          `<div>Subido el <strong>${new Date(uploadedAt).toLocaleString()}</strong></div>`,
          `<div>Procesado el <strong>${new Date(entry.timestamp).toLocaleString()}</strong></div>`,
        ];
        resultMeta.innerHTML = metaParts.join("");

        resultsNavigation.hidden = state.results.length <= 1;
        resultPosition.textContent = `Documento ${safeIndex + 1} de ${state.results.length}`;
        resultPosition.setAttribute("aria-live", "polite");
        prevResultBtn.disabled = safeIndex === 0;
        nextResultBtn.disabled = safeIndex === state.results.length - 1;
        downloadJson.disabled = false;
        downloadCsv.disabled = false;
        if (isPreviewDocked) {
          renderCurrentPreview(entry);
        }
        updateHighlightIndicators();
      }

      // Inserta una nueva entrada de resultados en la lista principal.
      function addResultEntry(data, source, options = {}) {
        const timestamp = Date.now();
        const entry = {
          id:
            typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
              ? crypto.randomUUID()
              : Math.random().toString(36).slice(2),
          data,
          source,
          timestamp,
          previewText:
            typeof options.previewText === "string" ? options.previewText : "",
          textOrigin:
            typeof options.textOrigin === "string" ? options.textOrigin : "",
          uploadedAt: options.uploadedAt || timestamp,
          editedFields: Object.create(null),
          prediction: null,
          predictionRequestId: 0,
          file:
            options.file && typeof options.file === "object" ? options.file : null,
          category:
            typeof options.category === "string" ? options.category : null,
        };
        state.results.push(entry);
        state.currentIndex = state.results.length - 1;
        renderResult(state.currentIndex);
      }

      if (previewModeButtons.length) {
        previewModeButtons.forEach((button) => {
          button.addEventListener("click", () => {
            if (button.disabled) {
              return;
            }
            const mode = button.dataset.mode;
            if (!mode || state.previewMode === mode) {
              return;
            }
            state.previewMode = mode;
            const entry = state.results[state.currentIndex] || null;
            updatePreviewModeControls(entry);
            updateViewContentButton(entry);
            if (isPreviewDocked) {
              renderCurrentPreview(entry);
            } else if (!previewModal.hidden) {
              const resolved = resolveActivePreviewMode(entry);
              if (resolved === "file" && entry) {
                showFilePreview(entry.file, entry.category, { entry });
              } else if (resolved === "text" && entry) {
                showPlainTextPreview(entry.previewText, entry.textOrigin || "");
              }
            }
          });
        });
      }

      prevResultBtn.addEventListener("click", () => {
        if (state.currentIndex > 0) {
          state.currentIndex -= 1;
          renderResult(state.currentIndex);
        }
      });

      nextResultBtn.addEventListener("click", () => {
        if (state.currentIndex < state.results.length - 1) {
          state.currentIndex += 1;
          renderResult(state.currentIndex);
        }
      });

      if (retryPredictionButton) {
        retryPredictionButton.addEventListener("click", () => {
          const entry = state.results[state.currentIndex];
          const features = collectPredictionFeatures(entry);
          if (entry) {
            renderPredictionCard(entry, features);
          }
          if (!entry || !features.ready) {
            return;
          }
          triggerPrediction(entry, features);
        });
      }

      if (retrainRandomForestButton) {
        const retrainDefaultLabel =
          retrainRandomForestButton.getAttribute("data-default-label") ||
          retrainRandomForestButton.textContent ||
          "Reentrenar Random Forest";
        retrainRandomForestButton.textContent = retrainDefaultLabel;
        retrainRandomForestButton.addEventListener("click", async () => {
          updateRetrainStatus(
            "Reentrenando el modelo. Esto puede tardar unos segundos..."
          );
          retrainRandomForestButton.disabled = true;
          retrainRandomForestButton.textContent = "Entrenando...";
          try {
            const response = await fetch(RETRAIN_ENDPOINT, { method: "POST" });
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            if (!response.ok) {
              const detail =
                payload && typeof payload.detail === "string"
                  ? payload.detail
                  : "No se pudo reentrenar el modelo.";
              throw new Error(detail);
            }
            const message =
              payload && typeof payload.mensaje === "string"
                ? payload.mensaje
                : "Reentrenamiento completado.";
            updateRetrainStatus(message, "success");
            markPredictionsAsStale();
          } catch (error) {
            const fallback =
              error && typeof error.message === "string" && error.message.trim()
                ? error.message
                : "No se pudo reentrenar el modelo.";
            updateRetrainStatus(fallback, "error");
          } finally {
            retrainRandomForestButton.disabled = false;
            retrainRandomForestButton.textContent = retrainDefaultLabel;
          }
        });
      }

      // Descarga contenido generado utilizando un enlace temporal.
      function downloadFile(content, filename, type) {
        const blob = new Blob([content], { type });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      }

      // Genera los blobs necesarios para las descargas disponibles.
      function buildDownloadPayloads() {
        const enriched = state.results.map((entry) => ({
          id: entry.id,
          archivo: entry.source,
          subido_en: new Date((entry.uploadedAt || entry.timestamp)).toISOString(),
          procesado_en: new Date(entry.timestamp).toISOString(),
          datos: entry.data,
          prediccion: getPredictionDownload(entry),
        }));
        return enriched;
      }

      downloadJson.addEventListener("click", () => {
        if (!state.results.length) return;
        const payload = buildDownloadPayloads();
        downloadFile(JSON.stringify(payload, null, 2), "resultados_verifactura.json", "application/json");
      });

      downloadCsv.addEventListener("click", () => {
        if (!state.results.length) return;
        const payload = buildDownloadPayloads();
        const allKeys = new Set(["id", "archivo", "subido_en", "procesado_en"]);
        payload.forEach((item) => {
          Object.keys(flattenData(item.datos)).forEach((key) => {
            if (!key) {
              allKeys.add("datos");
            } else {
              allKeys.add(`datos.${key}`);
            }
          });
          const predictionData =
            item.prediccion && typeof item.prediccion === "object" ? item.prediccion : null;
          if (predictionData) {
            Object.keys(flattenData(predictionData)).forEach((key) => {
              if (!key) {
                allKeys.add("prediccion");
              } else {
                allKeys.add(`prediccion.${key}`);
              }
            });
          }
        });
        const headers = Array.from(allKeys);
        const rows = payload.map((item) => {
          const flat = flattenData(item.datos);
          const predictionData =
            item.prediccion && typeof item.prediccion === "object" ? item.prediccion : null;
          const flatPrediction = predictionData ? flattenData(predictionData) : {};
          const values = headers.map((header) => {
            if (header === "id") return item.id;
            if (header === "archivo") return item.archivo;
            if (header === "subido_en") return item.subido_en;
            if (header === "procesado_en") return item.procesado_en;
            if (header === "datos" || header.startsWith("datos.")) {
              const dataKey = header === "datos" ? "" : header.replace(/^datos\./, "");
              const value = Object.prototype.hasOwnProperty.call(flat, dataKey)
                ? flat[dataKey]
                : null;
              if (value === null || value === undefined) {
                return "";
              }
              if (typeof value === "object") {
                return JSON.stringify(value);
              }
              return String(value);
            }
            if (header === "prediccion" || header.startsWith("prediccion.")) {
              const predictionKey =
                header === "prediccion" ? "" : header.replace(/^prediccion\./, "");
              const predictionValue = Object.prototype.hasOwnProperty.call(
                flatPrediction,
                predictionKey
              )
                ? flatPrediction[predictionKey]
                : null;
              if (predictionValue === null || predictionValue === undefined) {
                return "";
              }
              if (typeof predictionValue === "object") {
                return JSON.stringify(predictionValue);
              }
              return String(predictionValue);
            }
            const key = header === "datos" ? "" : header.replace(/^datos\./, "");
            const value = Object.prototype.hasOwnProperty.call(flat, key)
              ? flat[key]
              : null;
            if (value === null || value === undefined) {
              return "";
            }
            if (typeof value === "object") {
              return JSON.stringify(value);
            }
            return String(value);
          });
          return values
            .map((value) => {
              const escaped = String(value).replace(/"/g, '""');
              return `"${escaped}"`;
            })
            .join(",");
        });
        const csv = [headers.join(","), ...rows].join("\n");
        downloadFile(csv, "resultados_verifactura.csv", "text/csv;charset=utf-8");
      });

      if (viewContentButton) {
        viewContentButton.addEventListener("click", () => {
          openActivePreview();
        });
      }

      // Verifica que existan datos válidos antes de enviar al servidor.
      function validateBeforeSend() {
        if (state.mode === "text") {
          const value = plainText.value.trim();
          if (!value) {
            throw new Error("Ingresa texto para procesar.");
          }
          return { type: "text", payload: value };
        }
        if (state.mode === "multi" || state.mode === "testing") {
          if (!state.multiFiles.length || !state.multiCategory) {
            const message =
              state.mode === "testing"
                ? "Agrega al menos un documento de prueba para procesar."
                : "Agrega al menos un archivo para procesar en lote.";
            throw new Error(message);
          }
          return {
            type: "multi",
            payload: {
              category: state.multiCategory,
              entries: state.multiFiles.map((entry) => ({ ...entry })),
              useOcr:
                state.multiCategory === "pdf" || state.multiCategory === "image"
                  ? state.multiUseOcr
                  : false,
              useVision:
                state.multiCategory === "pdf" || state.multiCategory === "image"
                  ? state.multiUseVision
                  : false,
            },
          };
        }
        throw new Error("Selecciona un modo de procesamiento válido.");
      }

      async function sendText(text) {
        const activeSettings = getActiveLlmSettings();
        const payload = {
          text,
          llm_provider: state.llmProvider,
        };
        if (activeSettings.model) {
          payload.llm_model = activeSettings.model;
        }
        if (
          activeSettings.temperature_enabled === true &&
          Number.isFinite(activeSettings.temperature)
        ) {
          payload.temperature = activeSettings.temperature;
        }
        if (
          activeSettings.top_p_enabled === true &&
          Number.isFinite(activeSettings.top_p)
        ) {
          payload.top_p = activeSettings.top_p;
        }
        if (
          activeSettings.reasoning_effort_enabled === true &&
          typeof activeSettings.reasoning_effort === "string"
        ) {
          const value = activeSettings.reasoning_effort.trim();
          if (value) {
            payload.reasoning_effort = value;
          }
        }
        if (
          activeSettings.frequency_penalty_enabled === true &&
          Number.isFinite(activeSettings.frequency_penalty)
        ) {
          payload.frequency_penalty = activeSettings.frequency_penalty;
        }
        if (
          activeSettings.presence_penalty_enabled === true &&
          Number.isFinite(activeSettings.presence_penalty)
        ) {
          payload.presence_penalty = activeSettings.presence_penalty;
        }
        if (state.llmProvider === "api") {
          const apiKey = (activeSettings.api_key || "").trim();
          if (apiKey) {
            payload.openai_api_key = apiKey;
          }
        }
        const response = await fetch("/api/v1/extract/text", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const detail = await response.json().catch(() => ({}));
          throw new Error(detail.detail || "No se pudo procesar el texto.");
        }
        return response.json();
      }

      async function sendFile(file, type, options = {}) {
        const { useOcr = false, useVision = false } = options;
        const formData = new FormData();
        const fieldName = type === "image" ? "image" : "file";
        formData.append(fieldName, file);
        let endpoint = "/api/v1/extract/file";
        if (type === "image") {
          endpoint = "/api/v1/extract/image";
        }
        const url = new URL(endpoint, window.location.origin);
        if (type === "pdf" && useOcr) {
          url.searchParams.set("force_ocr", "true");
        }
        if (type === "image") {
          url.searchParams.set("use_ocr", String(Boolean(useOcr)));
        }
        url.searchParams.set("llm_provider", state.llmProvider);
        url.searchParams.set("use_vision", String(Boolean(useVision)));
        const activeSettings = getActiveLlmSettings();
        if (activeSettings.model) {
          url.searchParams.set("llm_model", activeSettings.model);
        }
        if (
          activeSettings.temperature_enabled === true &&
          Number.isFinite(activeSettings.temperature)
        ) {
          url.searchParams.set(
            "temperature",
            String(activeSettings.temperature)
          );
        }
        if (
          activeSettings.top_p_enabled === true &&
          Number.isFinite(activeSettings.top_p)
        ) {
          url.searchParams.set("top_p", String(activeSettings.top_p));
        }
        if (
          activeSettings.reasoning_effort_enabled === true &&
          typeof activeSettings.reasoning_effort === "string"
        ) {
          const value = activeSettings.reasoning_effort.trim();
          if (value) {
            url.searchParams.set("reasoning_effort", value);
          }
        }
        if (
          activeSettings.frequency_penalty_enabled === true &&
          Number.isFinite(activeSettings.frequency_penalty)
        ) {
          url.searchParams.set(
            "frequency_penalty",
            String(activeSettings.frequency_penalty)
          );
        }
        if (
          activeSettings.presence_penalty_enabled === true &&
          Number.isFinite(activeSettings.presence_penalty)
        ) {
          url.searchParams.set(
            "presence_penalty",
            String(activeSettings.presence_penalty)
          );
        }
        if (state.llmProvider === "api") {
          const apiKey = (activeSettings.api_key || "").trim();
          if (apiKey) {
            url.searchParams.set("openai_api_key", apiKey);
          }
        }
        const ocrSettings = getActiveOcrSettings();
        if (ocrSettings.provider) {
          url.searchParams.set("ocr_provider", ocrSettings.provider);
          if (ocrSettings.endpoint) {
            url.searchParams.set(
              "azure_form_recognizer_endpoint",
              ocrSettings.endpoint
            );
          }
          if (ocrSettings.key) {
            url.searchParams.set(
              "azure_form_recognizer_key",
              ocrSettings.key
            );
          }
        }
        const response = await fetch(url, {
          method: "POST",
          body: formData,
        });
        if (!response.ok) {
          const detail = await response.json().catch(() => ({}));
          throw new Error(detail.detail || "No se pudo procesar el archivo.");
        }
        return response.json();
      }

      async function handleSubmit() {
        try {
          setStatus("Procesando...", false);
          submitButton.disabled = true;
          const { type, payload } = validateBeforeSend();
          if (type === "text") {
            const now = Date.now();
            const result = await sendText(payload);
            const normalized = normalizeExtractionResponse(result, payload);
            addResultEntry(normalized.fields, "Ingreso manual", {
              uploadedAt: now,
              previewText: normalized.rawText,
              textOrigin: normalized.textOrigin || "input",
            });
            if (state.settings.autoClear) {
              plainText.value = "";
            }
        } else if (type === "multi") {
          const { category, entries, useOcr, useVision } = payload;
          showMultiProgress(entries.length);
          updateMultiProgress(0, entries.length);
          for (let index = 0; index < entries.length; index += 1) {
            const currentEntry = entries[index];
            setStatus(
              `Procesando factura ${index + 1} de ${entries.length}...`,
              false
            );
            const currentResult = await sendFile(currentEntry.file, category, {
              useOcr:
                category === "pdf" || category === "image" ? useOcr : false,
              useVision:
                category === "pdf" || category === "image" ? useVision : false,
            });
            const label = formatTypeLabel(category, {
              useOcr:
                (category === "pdf" || category === "image") && useOcr,
              useVision:
                (category === "pdf" || category === "image") && useVision,
            });
            const description = `${label} · ${currentEntry.file.name}`;
              const normalized = normalizeExtractionResponse(currentResult);
              addResultEntry(normalized.fields, description, {
                uploadedAt: currentEntry.uploadedAt || Date.now(),
                previewText: normalized.rawText,
                textOrigin: normalized.textOrigin,
                file: currentEntry.file,
                category,
              });
              updateMultiProgress(index + 1, entries.length);
            }
            if (state.settings.autoClear) {
              resetMultiFiles();
            } else {
              renderMultiList();
            }
          }
          setStatus("¡Extracción completada!", false);
        } catch (error) {
          console.error(error);
          resetMultiProgress();
          setStatus(error.message || "No se pudo completar la solicitud.", true);
        } finally {
          submitButton.disabled = false;
        }
      }

      submitButton.addEventListener("click", () => {
        setStatus("");
        handleSubmit();
      });

      plainText.addEventListener("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          submitButton.click();
        }
      });

      clearButton.addEventListener("click", () => {
        setStatus("");
        plainText.value = "";
        resetMultiFiles();
      });

      renderResult(state.currentIndex);
    </script>
  </body>
</html>
